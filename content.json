[{"title":"破解Wi-Fi密码","date":"2017-11-07T13:03:46.000Z","path":"2017/11/07/破解Wi-Fi密码/","text":"简介：目前无线渗透试的两种方法：1、抓握手包，跑包。2、通过WPS进行跑pin码当然第2种方法是要求路由器开启了wps功能。并且要求路由器没有设置pin防护，其它的方法如路由器漏洞等不在此讨论范围内。WEP方式认证的路由器已经很少了，而且这种认证方式不但非常不安全且绝对可破，不再讲解，本文只讲WPA认证方式的渗透方法。其实最有效的取得密码的方法是直接编个理由过去问！（社工）原理：抓到的包中有密码的密文，做暴力跑包即可。 工具： kali操作系统 一个支持监听模式的无线网卡 步骤：1.开启无线网卡监听模式 查看无线网卡 $ifconfig -a 可以从上图看出设备识别的无线网卡名字为wlan0 激活无线网卡 $ifconfig wlan0 up 没有任何提示，在linux下没有报错就是没有错 杀死干扰进程 $airmon-ng check kill 从上面图片可以看出，有关干扰进程都被杀掉 开启网卡监听模式 $airmon-ng start wlan0 使用上面的命令开启网卡的监听模式，记录下监听模式的名字，为mon0，如下图 再次查看设备，发现多出来一个监听模式的网卡信息，见下图 2.监听周围wifi状态，寻找要破解的无线路由器$airodump-ng mon0 使用上面的命令，可以监听到周围的无线网络，从中选择我们要破解的路由器的ssid，见下图 1:路由器mac地址 2:信号强度 3:路由器工作频道 4:wifi名字 5:连接在路由器的客户端的mac地址 3.监听要破解的路由器，攻击连接的无线设备使其自动掉线然后重连，来抓取握手包下面我们来破解名字为14_102的路由器，可以看出其mac地址为8C:A6:DF:69:DB:33，信道为6，使用下面命令监听该路由器并把监听的数据保存到名字为wifi里 $airodump-ng mon0 -c 6 --bssid 8C:A6:DF:69:DB:33 -w wifi -c:信道 –bssid:路由器mac地址 -w:保存数据的名字 在另一个终端来攻击连在该路由器的客户端，使其掉线然后自动重连，就能监控到含有密码的握手包 $aireplay-ng -0 1 -a 8C:A6:DF:69:DB:33 -c 00:CD:FE:65:46:5A mon0 -a:路由器mac地址 -c:客户端的mac地址，可以不加该参数，会把连在该路由器上的所有客户端搞掉线 测试的客户端是我的手机，发现手机掉线了，然后自动重新连接wifi。自动连接上后（握手成功），看到在监听端口出现如下标志，说明抓取握手包成功，可以停止攻击和监控 查看抓到的包的数据如下图 4.用字典跑包下面用我们的字典来跑抓到的数据包 $aircrack-ng -w dic.txt wifi-01.cap 成功爆出密码 说明：此文仅用于研究测试，请不要做破坏，博主不承担任何责任。。。。。。","tags":[{"name":"破解wifi","slug":"破解wifi","permalink":"http://www.an-time.top/tags/破解wifi/"},{"name":"kali","slug":"kali","permalink":"http://www.an-time.top/tags/kali/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://www.an-time.top/tags/aircrack-ng/"}]},{"title":"docker swarm集群搭建","date":"2017-11-06T03:28:22.000Z","path":"2017/11/06/docker-swarm集群搭建/","text":"简介：dokcer swarm是一个docker集群管理工具，把大量的docker容器集中管理，类似的还有k8s等。 准备：本案例需要2台以上机器，这里使用docker machine来生成3台虚拟机来测试。可根据自己资源多少来选择不同的方案。创建一个管理节点机器manager1，两个工作节点worker1和worker2 #docker-machine create --driver virtualbox manager1 #docker-machine create --driver virtualbox worker1 #docker-machine create --driver virtualbox worker2 现在，有两三台虚拟机，我们查看一下： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 创建swarm集群：用上面创建的3台虚拟机，来创建一个swarm集群，首先进入管理节点： #docker-machine ssh manager1 #docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100 Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager. To add a worker to this swarm, run the following command: docker swarm join \\ --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \\ 192.168.99.100:2377 To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions. 上面用 –listen-addr来指定监听的ip和端口。 接下来把worker1和worker2加入集群： #docker-machine ssh worker1 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 #docker-machine ssh worker2 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 上面可以加入参数–listen-addr作为监听准备，因为有时候可能遇到把一个worker节点提升为manager节点。本例不添加。 初始化成功后，现在，我们拥有了一个主节点两个从节点的swarm集群，进入管理节点查看一下相应信息： #docker-machine ssh manager1 #docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS tdbdcsorrtqymgmn71t5pfwxm * manager1 Ready Active Leader b5twxb6zeacvndsklkxenlhk2 worker1 Ready Active xdvapziebpux1iee52d4tvqa9 worker2 Ready Active 现在，每个节点都归属于swarm，并处于待机状态。manager1是管理节点，worker1和worker2是工作节点。 在管理节点上查看网络状态： #docker-machine ssh manager1 #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local 可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。 #docker network create --driver overlay swarm_test #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local n9jduvforkcm swarm_test overlay swarm 可以看到我们创建的网络swarm_test。 在跨主机网络上部署应用：首先，分别在各个节点上下载一个要部署应用的镜像： #docker-machine ssh manager1 #docker pull nginx #docker-machine ssh worker1 #docker pull nginx #docker-machine ssh worker2 #docker pull nginx 上面分别在3个节点上下载了nginx的镜像，下面在swarm中部署nginx应用： #docker service create --replicas 2 -p 7080:80 --name hello --networ=swarm_test nginx 查看服务： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS sl4zi20wk6um hello replicated 2/2 nginx:latest *:7080-&gt;80/tcp 查看hello的详细情况： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 0b3pykmkl7i9 hello.2 nginx:latest manager1 Running Running 2 hours ago s7ud2yba1p0r hello.3 nginx:latest worker1 Running Running 2 hours ago 可以看出，两个容器分别运行在管理节点和worker1节点。 swarm自我修复能力：上面我们创建的service里面有两个实例，现在我们尝试一下杀掉其中一个实例，观察其反应： 杀掉worker1中的容器： #docker-machine ssh worker1 #docker kill 4f9d65b4ab70 查看服务实例状态： #docker-machine ssh manager1 #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS z9jbg1psmh7n hello.1 nginx:latest worker1 Running Running 1 second ago jhfcp9axso7m \\_ hello.1 nginx:latest worker1 Shutdown Failed 7 seconds ago &quot;task: non-zero exit (137)&quot; y8rbt67vpkfe hello.2 nginx:latest manager1 Running Running 5 minutes ago 可以看到，其中一个容器为shutdown状态，然后又启动了另外一个容器来代替关闭的容器 动态修改实例数：假如某个服务负载过大，我们可以对该服务动态平滑的扩容，当负载减下来的时候，可以减少容器数量，只需指定scale参数即可。我们用上面创建的hello服务来说明： #docker-machines ssh manager1 #docker service scale hello=3 hello scaled to 3 overall progress: 3 out of 3 tasks 1/3: running [==================================================&gt;] 2/3: running [==================================================&gt;] 3/3: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成3个了： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS veq6koi71ff8 hello.1 nginx:latest manager1 Running Running 26 seconds ago e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 26 seconds ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 12 seconds ago 现在，我们把容器减少到2个： #docker service scale hello=2 hello scaled to 2 overall progress: 2 out of 2 tasks 1/2: running [==================================================&gt;] 2/2: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成了2: #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 3 minutes ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 3 minutes ago 删除服务：假如某个服务我们不在需要了，可以直接把高服务删除。现在我们把上面创建的hello服务删除： #docker-machines ssh managers1 #docker service rm hello 再次查看服务，发现hello服务已经被删除了： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS 删除节点：完成上面的测试，最终删除我们的虚拟机manager1，worker1和worker2: #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 删除虚拟机： #docker-machine rm manager1 worker1 worker2 About to remove manager1, worker1, worker2 WARNING: This action will delete both local reference and remote instance. Are you sure? (y/n): y Successfully removed manager1 Successfully removed worker1 Successfully removed worker2 再次查看，已经没有了： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS 结尾：swarm的基本姿势大致如上，我们可以把他用在我们的生产环境，与持续集成，持续部署等结合起来，最终可以达到无人值守的目的。","tags":[{"name":"docker swarm","slug":"docker-swarm","permalink":"http://www.an-time.top/tags/docker-swarm/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://www.an-time.top/tags/虚拟化/"},{"name":"集群","slug":"集群","permalink":"http://www.an-time.top/tags/集群/"}]},{"title":"短网址还原工具","date":"2017-10-24T01:20:10.000Z","path":"2017/10/24/短网址还原工具/","text":"简介：随着安全意识的不断提升，很多都开始使用短网址。这里写了一个小工具，实现把短网址还原成原来的网址。 实现：#coding = utf8 import urllib2, httplib, os, sys class RedirectHandler(urllib2.HTTPRedirectHandler): def http_error_301(self, req, fp, code, msg, headers): result = urllib2.HTTPRedirectHandler.http_error_301(self, req, fp, code, msg, headers) result.status = code return result def http_error_302(self, req, fp, code, msg, headers): result = urllib2.HTTPRedirectHandler.http_error_302(self, req, fp, code, msg, headers) result.status = code return result # Banner def Banner(): print(&quot;=================================================&quot;) print(&quot; pyLongURL &quot;) print(&quot;=================================================&quot;) # Usage def help_menu(cmd): print(&quot;Usage: %s &lt;short_URL&gt;\\n&quot;) % (cmd) print(&quot;Please enter need an URL!&quot;) def main(szURL): httplib.HTTPConnection.debuglevel = 1 request = urllib2.Request(szURL) opener = urllib2.build_opener(RedirectHandler()) f = opener.open(request) print(f.url) if __name__ == &quot;__main__&quot;: Banner() if len(sys.argv)&lt;2: help_menu(sys.argv[0]) else: main(sys.argv[1]) 测试：","tags":[{"name":"短网址还原","slug":"短网址还原","permalink":"http://www.an-time.top/tags/短网址还原/"},{"name":"工具","slug":"工具","permalink":"http://www.an-time.top/tags/工具/"}]},{"title":"用nginx搭建文件服务器","date":"2017-09-22T03:15:53.000Z","path":"2017/09/22/用nginx搭建文件服务器/","text":"简介工作需要，搭建一个文件服务器。 环境介绍先创建一台虚拟机，ip地址为：106.14.242.15 实战 配置源系统源 # wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装nginx # yum install nginx -y 查找配置文件 # rpm -qc nginx 可以看到配置文件如下图： 修改配置文件 #cat /etc/nginx/nginx.conf # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; events { worker_connections 1024; } http { log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 ; server_name test.file.com; charset utf-8; # Load configuration files for the default server block. location / { root /data; index index.php index.html index.htm; autoindex on; autoindex_exact_size on; autoindex_localtime on; } access_log /var/log/file.log; error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 创建文件目录和测试数据 # mkdir /data # cd /data # touch 123.txt # echo &apos;test&apos; &gt; 123.txt 结果测试浏览器访问地址，如下图：","tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.an-time.top/tags/nginx/"},{"name":"文件服务器","slug":"文件服务器","permalink":"http://www.an-time.top/tags/文件服务器/"}]},{"title":"Markdown教程","date":"2017-08-14T14:54:19.000Z","path":"2017/08/14/Markdown教程/","text":"简介：Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式。 1. 标题为了获得上面的 “1. 标题”， 在 Markdown 编辑器里输入： 1# 1. 标题 “#” 后最好加个空格。除此之外，还有 5 级标题，依次有不同的字体大小，即 12345## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这样就有： 二级标题三级标题四级标题五级标题六级标题 2. 字体最常用的强调方式，那就是 加粗 了，你得这样： 1最常用的强调方式，那就是 **加粗** 了，你得这样： 通常我喜欢在 “**加粗的部分**” 旁边各加一个空格，当然你也可以不这样。斜体则多用在于书名，比如：我从来没看过 Jane Eyre 1斜体则多用在于书名，比如：我从来没看过 *Jane Eyre* 但中文的斜体我觉得真是不美，像：《简 · 爱》，一般还是别用了。 3. 层次比如写个读书笔记，你得 第一章 第一节 第二节(你不用敲 “2”，自动就有了） 第一小节（推荐每层次缩进四个空格） 小小节 1 小小节 2 第二小节 也不难： 12345678#### 第一章1. 第一节* 第二节(你不用敲 &quot;2&quot;，自动就有了） * 第一小节（推荐每层次缩进四个空格） * 小小节 1 * 小小节 2 * 第二小节 “*” 后面要加空格，这是必须的，除了 *，还可以使用 + 或者 -。 如果格式出现问题，多加个空行，一般就好了。 4. 链接，图片你：我没读过 Jane Eyre我：以后别跟我说话！你：。。。我：我也没读过，但是， Jane Eyre is not just Jane Eyre 12我：我也没读过，但是， [***Jane Eyre***](http://book.douban.com/subject/1141406/) is not just ***Jane Eyre***![](http://img3.douban.com/mpic/s1108264.jpg) 5. 其他你可能还没注意到本文每部分之间的分割线和 其他 的链接其实没有链接我爱 分割线， 我爱 链接，哪怕它只有颜色~ 12345678---# [5. 其他][null-link]你可能还没注意到本文每部分之间的分割线和 `其他` 的链接其实没有链接我爱 `分割线`， 我爱 [**链接**][null-link]，哪怕它只有颜色~[null-link]: chrome://not-a-link “---” 的上下最好各空一行 P.S. 补充一种高端的链接: 鼠标移过来，先别单击 ~ 代码如下： 12**P.S.** 补充一种高端的链接: [鼠标移过来，**先别单击** ~][hover][hover]: http://www.google.com.sg &quot;Google Sg 更快，更好用。好，现在单击吧&quot; （可惜 Google 被墙了） P.P.S. 图片链接：(点击图片可跳转） 代码如下：123[![][jane-eyre-pic]][jane-eyre-douban][jane-eyre-pic]: http://img3.douban.com/mpic/s1108264.jpg[jane-eyre-douban]: http://book.douban.com/subject/1141406/ （简书最新的 Markdown 不能使用图片链接。。。感受不爱）P.P.P.S. 更多的 Markdown 特性测试，见我的 Markdown 一篇博客 在简书中输入数学公式：见我的 简书中编辑数学公式 如何写出漂亮的 Markdown 文章？戳 Markdown 写作规范参考","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.an-time.top/tags/Markdown/"}]}]