[{"title":"破解Wi-Fi密码","date":"2017-11-07T13:03:46.000Z","path":"2017/11/07/破解Wi-Fi密码/","text":"简介：目前无线渗透试的两种方法：1、抓握手包，跑包。2、通过WPS进行跑pin码当然第2种方法是要求路由器开启了wps功能。并且要求路由器没有设置pin防护，其它的方法如路由器漏洞等不在此讨论范围内。WEP方式认证的路由器已经很少了，而且这种认证方式不但非常不安全且绝对可破，不再讲解，本文只讲WPA认证方式的渗透方法。其实最有效的取得密码的方法是直接编个理由过去问！（社工）原理：抓到的包中有密码的密文，做暴力跑包即可。 工具： kali操作系统 一个支持监听模式的无线网卡 步骤：1.开启无线网卡监听模式 查看无线网卡 $ifconfig -a 可以从上图看出设备识别的无线网卡名字为wlan0 激活无线网卡 $ifconfig wlan0 up 没有任何提示，在linux下没有报错就是没有错 杀死干扰进程 $airmon-ng check kill 从上面图片可以看出，有关干扰进程都被杀掉 开启网卡监听模式 $airmon-ng start wlan0 使用上面的命令开启网卡的监听模式，记录下监听模式的名字，为mon0，如下图 再次查看设备，发现多出来一个监听模式的网卡信息，见下图 2.监听周围wifi状态，寻找要破解的无线路由器$airodump-ng mon0 使用上面的命令，可以监听到周围的无线网络，从中选择我们要破解的路由器的ssid，见下图 1:路由器mac地址 2:信号强度 3:路由器工作频道 4:wifi名字 5:连接在路由器的客户端的mac地址 3.监听要破解的路由器，攻击连接的无线设备使其自动掉线然后重连，来抓取握手包下面我们来破解名字为14_102的路由器，可以看出其mac地址为8C:A6:DF:69:DB:33，信道为6，使用下面命令监听该路由器并把监听的数据保存到名字为wifi里 $airodump-ng mon0 -c 6 --bssid 8C:A6:DF:69:DB:33 -w wifi -c:信道 –bssid:路由器mac地址 -w:保存数据的名字 在另一个终端来攻击连在该路由器的客户端，使其掉线然后自动重连，就能监控到含有密码的握手包 $aireplay-ng -0 1 -a 8C:A6:DF:69:DB:33 -c 00:CD:FE:65:46:5A mon0 -a:路由器mac地址 -c:客户端的mac地址，可以不加该参数，会把连在该路由器上的所有客户端搞掉线 测试的客户端是我的手机，发现手机掉线了，然后自动重新连接wifi。自动连接上后（握手成功），看到在监听端口出现如下标志，说明抓取握手包成功，可以停止攻击和监控 查看抓到的包的数据如下图 4.用字典跑包下面用我们的字典来跑抓到的数据包 $aircrack-ng -w dic.txt wifi-01.cap 成功爆出密码 说明：此文仅用于研究测试，请不要做破坏，博主不承担任何责任。。。。。。","tags":[{"name":"破解wifi","slug":"破解wifi","permalink":"http://www.an-time.top/tags/破解wifi/"},{"name":"kali","slug":"kali","permalink":"http://www.an-time.top/tags/kali/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://www.an-time.top/tags/aircrack-ng/"}]},{"title":"docker swarm集群搭建","date":"2017-11-06T03:28:22.000Z","path":"2017/11/06/docker-swarm集群搭建/","text":"简介：dokcer swarm是一个docker集群管理工具，把大量的docker容器集中管理，类似的还有k8s等。 准备：本案例需要2台以上机器，这里使用docker machine来生成3台虚拟机来测试。可根据自己资源多少来选择不同的方案。创建一个管理节点机器manager1，两个工作节点worker1和worker2 #docker-machine create --driver virtualbox manager1 #docker-machine create --driver virtualbox worker1 #docker-machine create --driver virtualbox worker2 现在，有两三台虚拟机，我们查看一下： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 创建swarm集群：用上面创建的3台虚拟机，来创建一个swarm集群，首先进入管理节点： #docker-machine ssh manager1 #docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100 Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager. To add a worker to this swarm, run the following command: docker swarm join \\ --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \\ 192.168.99.100:2377 To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions. 上面用 –listen-addr来指定监听的ip和端口。 接下来把worker1和worker2加入集群： #docker-machine ssh worker1 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 #docker-machine ssh worker2 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 上面可以加入参数–listen-addr作为监听准备，因为有时候可能遇到把一个worker节点提升为manager节点。本例不添加。 初始化成功后，现在，我们拥有了一个主节点两个从节点的swarm集群，进入管理节点查看一下相应信息： #docker-machine ssh manager1 #docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS tdbdcsorrtqymgmn71t5pfwxm * manager1 Ready Active Leader b5twxb6zeacvndsklkxenlhk2 worker1 Ready Active xdvapziebpux1iee52d4tvqa9 worker2 Ready Active 现在，每个节点都归属于swarm，并处于待机状态。manager1是管理节点，worker1和worker2是工作节点。 在管理节点上查看网络状态： #docker-machine ssh manager1 #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local 可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。 #docker network create --driver overlay swarm_test #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local n9jduvforkcm swarm_test overlay swarm 可以看到我们创建的网络swarm_test。 在跨主机网络上部署应用：首先，分别在各个节点上下载一个要部署应用的镜像： #docker-machine ssh manager1 #docker pull nginx #docker-machine ssh worker1 #docker pull nginx #docker-machine ssh worker2 #docker pull nginx 上面分别在3个节点上下载了nginx的镜像，下面在swarm中部署nginx应用： #docker service create --replicas 2 -p 7080:80 --name hello --networ=swarm_test nginx 查看服务： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS sl4zi20wk6um hello replicated 2/2 nginx:latest *:7080-&gt;80/tcp 查看hello的详细情况： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 0b3pykmkl7i9 hello.2 nginx:latest manager1 Running Running 2 hours ago s7ud2yba1p0r hello.3 nginx:latest worker1 Running Running 2 hours ago 可以看出，两个容器分别运行在管理节点和worker1节点。 swarm自我修复能力：上面我们创建的service里面有两个实例，现在我们尝试一下杀掉其中一个实例，观察其反应： 杀掉worker1中的容器： #docker-machine ssh worker1 #docker kill 4f9d65b4ab70 查看服务实例状态： #docker-machine ssh manager1 #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS z9jbg1psmh7n hello.1 nginx:latest worker1 Running Running 1 second ago jhfcp9axso7m \\_ hello.1 nginx:latest worker1 Shutdown Failed 7 seconds ago &quot;task: non-zero exit (137)&quot; y8rbt67vpkfe hello.2 nginx:latest manager1 Running Running 5 minutes ago 可以看到，其中一个容器为shutdown状态，然后又启动了另外一个容器来代替关闭的容器 动态修改实例数：假如某个服务负载过大，我们可以对该服务动态平滑的扩容，当负载减下来的时候，可以减少容器数量，只需指定scale参数即可。我们用上面创建的hello服务来说明： #docker-machines ssh manager1 #docker service scale hello=3 hello scaled to 3 overall progress: 3 out of 3 tasks 1/3: running [==================================================&gt;] 2/3: running [==================================================&gt;] 3/3: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成3个了： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS veq6koi71ff8 hello.1 nginx:latest manager1 Running Running 26 seconds ago e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 26 seconds ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 12 seconds ago 现在，我们把容器减少到2个： #docker service scale hello=2 hello scaled to 2 overall progress: 2 out of 2 tasks 1/2: running [==================================================&gt;] 2/2: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成了2: #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 3 minutes ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 3 minutes ago 删除服务：假如某个服务我们不在需要了，可以直接把高服务删除。现在我们把上面创建的hello服务删除： #docker-machines ssh managers1 #docker service rm hello 再次查看服务，发现hello服务已经被删除了： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS 删除节点：完成上面的测试，最终删除我们的虚拟机manager1，worker1和worker2: #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 删除虚拟机： #docker-machine rm manager1 worker1 worker2 About to remove manager1, worker1, worker2 WARNING: This action will delete both local reference and remote instance. Are you sure? (y/n): y Successfully removed manager1 Successfully removed worker1 Successfully removed worker2 再次查看，已经没有了： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS 结尾：swarm的基本姿势大致如上，我们可以把他用在我们的生产环境，与持续集成，持续部署等结合起来，最终可以达到无人值守的目的。","tags":[{"name":"docker swarm","slug":"docker-swarm","permalink":"http://www.an-time.top/tags/docker-swarm/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://www.an-time.top/tags/虚拟化/"},{"name":"集群","slug":"集群","permalink":"http://www.an-time.top/tags/集群/"}]}]