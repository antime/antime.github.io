<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑色时间</title>
  
  <subtitle>在时间的长河中，每一个人生,每一个事迹都是沧海里的一粟，人们苦苦追求，穿越那片黑色的时间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.an-time.top/"/>
  <updated>2017-11-07T13:26:42.000Z</updated>
  <id>http://www.an-time.top/</id>
  
  <author>
    <name>an_time</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>破解Wi-Fi密码</title>
    <link href="http://www.an-time.top/2017/11/07/%E7%A0%B4%E8%A7%A3Wi-Fi%E5%AF%86%E7%A0%81/"/>
    <id>http://www.an-time.top/2017/11/07/破解Wi-Fi密码/</id>
    <published>2017-11-07T13:03:46.000Z</published>
    <updated>2017-11-07T13:26:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>目前无线渗透试的两种方法：1、抓握手包，跑包。2、通过WPS进行跑pin码 </p><p>当然第2种方法是要求路由器开启了wps功能。并且要求路由器没有设置pin防护，其它的方法如路由器漏洞等不在此讨论范围内。</p><p>WEP方式认证的路由器已经很少了，而且这种认证方式不但非常不安全且绝对可破，不再讲解，本文只讲WPA认证方式的渗透方法。<br>其实最有效的取得密码的方法是直接编个理由过去问！（社工）<br>原理：抓到的包中有密码的密文，做暴力跑包即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h1&gt;&lt;p&gt;目前无线渗透试的两种方法：1、抓握手包，跑包。2、通过WPS进行跑pin码 &lt;/p&gt;
&lt;p&gt;当然第2种方法是要求路由器开启了wps功
      
    
    </summary>
    
    
      <category term="破解wifi" scheme="http://www.an-time.top/tags/%E7%A0%B4%E8%A7%A3wifi/"/>
    
      <category term="kali" scheme="http://www.an-time.top/tags/kali/"/>
    
      <category term="aircrack-ng" scheme="http://www.an-time.top/tags/aircrack-ng/"/>
    
  </entry>
  
  <entry>
    <title>docker swarm集群搭建</title>
    <link href="http://www.an-time.top/2017/11/06/docker-swarm%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.an-time.top/2017/11/06/docker-swarm集群搭建/</id>
    <published>2017-11-06T03:28:22.000Z</published>
    <updated>2017-11-06T06:54:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>dokcer swarm是一个docker集群管理工具，把大量的docker容器集中管理，类似的还有k8s等。</p><h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h1><p>本案例需要2台以上机器，这里使用docker machine来生成3台虚拟机来测试。可根据自己资源多少来选择不同的方案。<br>创建一个管理节点机器manager1，两个工作节点worker1和worker2</p><pre><code>#docker-machine create --driver virtualbox manager1#docker-machine create --driver virtualbox worker1#docker-machine create --driver virtualbox worker2</code></pre><p>现在，有两三台虚拟机，我们查看一下：</p><pre><code>#docker-machine lsNAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORSmanager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.10.0-ceworker1    -        virtualbox   Running   tcp://192.168.99.103:2376           v17.10.0-ceworker2    -        virtualbox   Running   tcp://192.168.99.104:2376           v17.10.0-ce</code></pre><h1 id="创建swarm集群："><a href="#创建swarm集群：" class="headerlink" title="创建swarm集群："></a>创建swarm集群：</h1><p>用上面创建的3台虚拟机，来创建一个swarm集群，首先进入管理节点：</p><pre><code>#docker-machine ssh manager1#docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager.To add a worker to this swarm, run the following command:docker swarm join \--token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \192.168.99.100:2377To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</code></pre><p>上面用 –listen-addr来指定监听的ip和端口。</p><p>接下来把worker1和worker2加入集群：</p><pre><code>#docker-machine ssh worker1#docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377#docker-machine ssh worker2#docker swarm join --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r 192.168.99.100:2377</code></pre><p>上面可以加入参数–listen-addr作为监听准备，因为有时候可能遇到把一个worker节点提升为manager节点。本例不添加。</p><p>初始化成功后，现在，我们拥有了一个主节点两个从节点的swarm集群，进入管理节点查看一下相应信息：</p><pre><code>#docker-machine ssh manager1#docker node lsID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUStdbdcsorrtqymgmn71t5pfwxm *   manager1            Ready               Active              Leaderb5twxb6zeacvndsklkxenlhk2     worker1             Ready               Activexdvapziebpux1iee52d4tvqa9     worker2             Ready               Active</code></pre><p>现在，每个节点都归属于swarm，并处于待机状态。manager1是管理节点，worker1和worker2是工作节点。</p><p>在管理节点上查看网络状态：</p><pre><code>#docker-machine ssh manager1#docker network lsNETWORK ID          NAME                DRIVER              SCOPEde994a4d6a4f        bridge              bridge              localca45f2e489de        docker_gwbridge     bridge              local3d22755e453b        host                host                localrgpmn1hh5qe1        ingress             overlay             swarm86b55cffdbd2        none                null                local</code></pre><p>可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。</p><pre><code>#docker network create --driver overlay swarm_test#docker network lsNETWORK ID          NAME                DRIVER              SCOPEde994a4d6a4f        bridge              bridge              localca45f2e489de        docker_gwbridge     bridge              local3d22755e453b        host                host                localrgpmn1hh5qe1        ingress             overlay             swarm86b55cffdbd2        none                null                localn9jduvforkcm        swarm_test          overlay             swarm</code></pre><p>可以看到我们创建的网络swarm_test。</p><h1 id="在跨主机网络上部署应用："><a href="#在跨主机网络上部署应用：" class="headerlink" title="在跨主机网络上部署应用："></a>在跨主机网络上部署应用：</h1><p>首先，分别在各个节点上下载一个要部署应用的镜像：</p><pre><code>#docker-machine ssh manager1#docker pull nginx#docker-machine ssh worker1#docker pull nginx#docker-machine ssh worker2#docker pull nginx</code></pre><p>上面分别在3个节点上下载了nginx的镜像，下面在swarm中部署nginx应用：</p><pre><code>#docker service create --replicas 2 -p 7080:80 --name hello --networ=swarm_test nginx</code></pre><p>查看服务：</p><pre><code>#docker service lsID                  NAME                MODE                REPLICAS            IMAGE               PORTSsl4zi20wk6um        hello               replicated          2/2                 nginx:latest        *:7080-&gt;80/tcp</code></pre><p>查看hello的详细情况：</p><pre><code>#docker service ps helloID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE         ERROR               PORTS0b3pykmkl7i9        hello.2             nginx:latest        manager1            Running             Running 2 hours agos7ud2yba1p0r        hello.3             nginx:latest        worker1             Running             Running 2 hours ago</code></pre><p>可以看出，两个容器分别运行在管理节点和worker1节点。</p><h1 id="swarm自我修复能力："><a href="#swarm自我修复能力：" class="headerlink" title="swarm自我修复能力："></a>swarm自我修复能力：</h1><p>上面我们创建的service里面有两个实例，现在我们尝试一下杀掉其中一个实例，观察其反应：</p><ol><li><p>杀掉worker1中的容器：</p><pre><code>#docker-machine ssh worker1#docker kill 4f9d65b4ab70</code></pre></li><li><p>查看服务实例状态：</p><pre><code>#docker-machine ssh manager1#docker service ps helloID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR                         PORTSz9jbg1psmh7n        hello.1             nginx:latest        worker1             Running             Running 1 second agojhfcp9axso7m         \_ hello.1         nginx:latest        worker1             Shutdown            Failed 7 seconds ago    &quot;task: non-zero exit (137)&quot;y8rbt67vpkfe        hello.2             nginx:latest        manager1            Running             Running 5 minutes ago</code></pre><p>可以看到，其中一个容器为shutdown状态，然后又启动了另外一个容器来代替关闭的容器</p></li></ol><h1 id="动态修改实例数："><a href="#动态修改实例数：" class="headerlink" title="动态修改实例数："></a>动态修改实例数：</h1><p>假如某个服务负载过大，我们可以对该服务动态平滑的扩容，当负载减下来的时候，可以减少容器数量，只需指定scale参数即可。我们用上面创建的hello服务来说明：</p><pre><code>#docker-machines ssh manager1#docker service scale hello=3hello scaled to 3overall progress: 3 out of 3 tasks1/3: running   [==================================================&gt;]2/3: running   [==================================================&gt;]3/3: running   [==================================================&gt;]verify: Service converged</code></pre><p>此时，查看服务，发现容器数量变成3个了：</p><pre><code>#docker service ps helloID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTSveq6koi71ff8        hello.1             nginx:latest        manager1            Running             Running 26 seconds agoe42vqpp5fvbf        hello.2             nginx:latest        worker1             Running             Running 26 seconds agotic4n5absao7        hello.3             nginx:latest        worker2             Running             Running 12 seconds ago</code></pre><p>现在，我们把容器减少到2个：</p><pre><code>#docker service scale hello=2hello scaled to 2overall progress: 2 out of 2 tasks1/2: running   [==================================================&gt;]2/2: running   [==================================================&gt;]verify: Service converged</code></pre><p>此时，查看服务，发现容器数量变成了2:</p><pre><code>#docker service ps helloID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTSe42vqpp5fvbf        hello.2             nginx:latest        worker1             Running             Running 3 minutes agotic4n5absao7        hello.3             nginx:latest        worker2             Running             Running 3 minutes ago</code></pre><h1 id="删除服务："><a href="#删除服务：" class="headerlink" title="删除服务："></a>删除服务：</h1><p>假如某个服务我们不在需要了，可以直接把高服务删除。现在我们把上面创建的hello服务删除：</p><pre><code>#docker-machines ssh managers1#docker service rm hello</code></pre><p>再次查看服务，发现hello服务已经被删除了：</p><pre><code>#docker service lsID                  NAME                MODE                REPLICAS            IMAGE               PORTS</code></pre><h1 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h1><p>完成上面的测试，最终删除我们的虚拟机manager1，worker1和worker2:</p><pre><code>#docker-machine lsNAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORSmanager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.10.0-ceworker1    -        virtualbox   Running   tcp://192.168.99.103:2376           v17.10.0-ceworker2    -        virtualbox   Running   tcp://192.168.99.104:2376           v17.10.0-ce</code></pre><p>删除虚拟机：</p><pre><code>#docker-machine rm manager1 worker1 worker2About to remove manager1, worker1, worker2WARNING: This action will delete both local reference and remote instance.Are you sure? (y/n): ySuccessfully removed manager1Successfully removed worker1Successfully removed worker2</code></pre><p>再次查看，已经没有了：</p><pre><code>#docker-machine lsNAME   ACTIVE   DRIVER   STATE   URL   SWARM   DOCKER   ERRORS</code></pre><h1 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h1><p>swarm的基本姿势大致如上，我们可以把他用在我们的生产环境，与持续集成，持续部署等结合起来，最终可以达到无人值守的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h1&gt;&lt;p&gt;dokcer swarm是一个docker集群管理工具，把大量的docker容器集中管理，类似的还有k8s等。&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="docker swarm" scheme="http://www.an-time.top/tags/docker-swarm/"/>
    
      <category term="虚拟化" scheme="http://www.an-time.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="集群" scheme="http://www.an-time.top/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
</feed>
